#ifndef I960_REGS_H__
#define I960_REGS_H__
#include "types.h"
namespace i960 {
    union ArithmeticControls {
        struct {
            Ordinal _conditionCode : 3;
            /**
             * Used to record results from the classify real (classr and classrl)
             * and remainder real (remr and remrl) instructions. 
             */
            Ordinal _arithmeticStatusField : 4;
            /**
             * Reserved, bind to zero always
             */
            Ordinal _reserved0 : 1 ; 
            /**
             * Denotes an integer overflow happened
             */
            Ordinal _integerOverflowFlag : 1;

            /**
             * Reserved, bind to zero always
             */
            Ordinal _reserved1 : 3;
            /**
             * Inhibit the processor from invoking a fault handler
             * when integer overflow is detected.
             */
            Ordinal _integerOverflowMask : 1;
            /**
             * Reserved, always bind to zero
             */
            Ordinal _reserved2 : 2;
            /**
             * Disable faults generated by imprecise results being generated
             */
            Ordinal _noImpreciseResults : 1;
            /**
             * Floating point overflow happened?
             */
            Ordinal _floatingOverflowFlag : 1;
            /**
             * Floating point underflow happened?
             */
            Ordinal _floatingUnderflowFlag : 1;
            /**
             * Floating point invalid operation happened?
             */
            Ordinal _floatingInvalidOperationFlag : 1;
            /**
             * Floating point divide by zero happened?
             */
            Ordinal _floatingZeroDivideFlag : 1;
            /**
             * Floating point rounding result was inexact?
             */
            Ordinal _floatingInexactFlag : 1;
            /**
             * Reserved, always bind to zero
             */
            Ordinal _reserved3 : 3;
            /**
             * Don't fault on fp overflow?
             */
            Ordinal _floatingOverflowMask : 1;
            /**
             * Don't fault on fp underflow?
             */
            Ordinal _floatingUnderflowMask : 1;
            /**
             * Don't fault on fp invalid operation?
             */
            Ordinal _floatingInvalidOperationMask : 1;
            /**
             * Don't fault on fp div by zero?
             */
            Ordinal _floatingZeroDivideMask : 1;
            /**
             * Don't fault on fp round producing an inexact representation?
             */
            Ordinal _floatingInexactMask : 1;
            /**
             * Enable to produce normalized values, disable to produce unnormalized values (useful for software simulation).
             * Note that the processor will fault if it encounters denormalized fp values!
             */
            Ordinal _normalizingModeFlag : 1;
            /**
             * What kind of fp rounding should be performed?
             * Modes:
             *  0: round up (towards positive infinity)
             *  1: round down (towards negative infinity)
             *  2: Round toward zero (truncate)
             *  3: Round to nearest (even)
             */
            Ordinal _roundingControl : 2;
        };
        Ordinal _value;
    };
    using InstructionPointer = Ordinal;
    union ProcessControls {
        // TODO add breakdown
        Ordinal _value;
    };
    union TraceControls {
        // TODO add value breakdown
        Ordinal _value;
    };
    constexpr auto GlobalRegisterCount = 16;
    constexpr auto NumFloatingPointRegs = 4;
    constexpr auto LocalRegisterCount = 16;
    constexpr Ordinal LargestAddress = 0xFFFF'FFFF;
    constexpr Ordinal LowestAddress = 0;
    /**
     * Regions zero through two are process specific
     * Region three is shared by all processes
     */
    constexpr Ordinal Region0StartAddress = LowestAddress;
    constexpr Ordinal Region0LastAddress = 0x3FFF'FFFF;
    constexpr Ordinal Region1StartAddress = 0x4000'0000;
    constexpr Ordinal Region1LastAddress = 0x7FFF'FFFF;
    constexpr Ordinal Region2StartAddress = 0x8000'0000;
    constexpr Ordinal Region2LastAddress = 0xBFFF'FFFF;
    constexpr Ordinal Region3StartAddress = 0xC000'0000;
    constexpr Ordinal Region3LastAddress = LargestAddress;

    constexpr Ordinal ConditionCodeTrue = 0b010;
    constexpr Ordinal ConditionCodeFalse = 0b000;
    constexpr Ordinal ConditionCodeUnordered = 0b000;
    constexpr Ordinal ConditionCodeGreaterThan = 0b001;
    constexpr Ordinal ConditionCodeEqual = 0b010;
    constexpr Ordinal ConditionCodeLessThan = 0b100;
    constexpr Ordinal ConditionCodeOrdered = 0b111;
    constexpr Ordinal ConditionCodeNotEqual = 0b101;
    constexpr Ordinal ConditionCodeLessThanOrEqual = 0b110;
    constexpr Ordinal ConditionCodeGreaterThanOrEqual = 0b011;

    /**
     * Aritmetic status bits, four bits wide with a sign bit as the upper most 
     * bit of this field. It is taken from the sign of the value being 
     * classified.
     */
    enum ArithmeticStatusCode : Ordinal {
        Zero = 0b000,
        DenormalizedNumber,
        NormalFiniteNumber,
        QuietNaN,
        SignalingNaN,
        ReservedOperand,
    };

    enum FloatingPointRoundingControl : Ordinal {
        RoundToNearest = 0,
        RoundDown,
        RoundUp,
        Truncate,
    };

}

#endif
