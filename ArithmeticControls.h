#ifndef I960_ARITHMETIC_CONTROLS_H__
#define I960_ARITHMETIC_CONTROLS_H__

#include "types.h"
namespace i960 {
    /**
     * Arithmetic controls register, will eventually encompass all modes, core architecture only now.
     */
    class ArithmeticControls {
        public:
            constexpr ArithmeticControls(Ordinal rawValue) noexcept : 
                _conditionCode(extractConditionCode(rawValue)),
                _integerOverflowFlag(extractIntegerOverflowFlag(rawValue)),
                _integerOverflowMask(extractIntegerOverflowMask(rawValue)),
                _noImpreciseFaults(extractNoImpreciseFaults(rawValue)) { }
            constexpr ArithmeticControls() noexcept = default;
            ~ArithmeticControls() = default;
            constexpr auto getConditionCode() const noexcept { return _conditionCode; }
            template<Ordinal mask = 0b111>
            constexpr auto getConditionCode() const noexcept { 
                if constexpr (mask >= 0b111) {
                    return _conditionCode;
                } else if constexpr (mask == 0) {
                    return 0;
                } else {
                    return _conditionCode & mask;
                }
            }

            constexpr auto getConditionCode(Ordinal mask) const noexcept {
                return _conditionCode & mask;
            }

            constexpr auto integerOverflowFlagSet() const noexcept { return _integerOverflowFlag; }
            constexpr auto maskIntegerOverflow() const noexcept { return _integerOverflowMask; }
            constexpr auto noImpreciseFaults() const noexcept { return _noImpreciseFaults; }
            void setConditionCode(Ordinal value) noexcept { _conditionCode = value; }
            void setIntegerOverflowFlag(bool value) noexcept { _integerOverflowFlag = value; }
            void setIntegerOverflowMask(bool value) noexcept { _integerOverflowMask = value; }
            void setNoImpreciseFaults(bool value) noexcept { _noImpreciseFaults = value; }
            void clearConditionCode() noexcept { _conditionCode = 0; }
            template<Ordinal mask>
            constexpr auto conditionCodeIs() const noexcept { return _conditionCode == mask; }
            constexpr auto conditionCodeIs(Ordinal mask) const noexcept { return _conditionCode == mask; }
            template<Ordinal mask>
            constexpr bool conditionCodeBitSet() const noexcept { return getConditionCode<mask>() != 0; }
            constexpr bool conditionCodeBitSet(Ordinal mask) const noexcept { return getConditionCode(mask) != 0; }
            constexpr bool shouldCarryOut() const noexcept {
                // 0b01X where X is don't care
                return _conditionCode == 0b010 || _conditionCode == 0b011;
            }
            constexpr bool markedAsOverflow() const noexcept {
                // 0b0X1 where X is don't care
                return _conditionCode == 0b001 || _conditionCode == 0b011;
            }
            constexpr bool carrySet() const noexcept { return conditionCodeBitSet<0b010>(); }
            constexpr Ordinal getCarryValue() const noexcept { return carrySet() ? 1 : 0; }
        private:
            Ordinal _conditionCode = 0;
            /**
             * Denotes an integer overflow happened
             */
            bool _integerOverflowFlag = false;
            /**
             * Inhibit the processor from invoking a fault handler
             * when integer overflow is detected.
             */
            bool _integerOverflowMask = false;
            /**
             * Disable faults generated by imprecise results being generated
             */
            bool _noImpreciseFaults = false;
        public:
            static constexpr Ordinal CoreArchitectureReservedMask = 0xFFFF'6EF8;
            static constexpr Ordinal CoreArchitectureExtractMask = ~CoreArchitectureReservedMask;
#if 0
                struct {
                    // Core architecture AC
                    Ordinal _conditionCode : 3; // 0x0000'0003
                    Ordinal reserved0 : 5;      // ~0x0000'00F8
                    Ordinal _integerOverflowFlag : 1; // 0x0000'0100
                    Ordinal reserved1 : 3;            // ~0x0000'0E00
                    Ordinal _integerOverflowMask : 1; // 0x0000'1000
                    Ordinal reserved2 : 2;            // ~0x0000'6000
                    Ordinal _noImpreciseFaults : 1;   // 0x0000'8000
                    Ordinal reserved3 : 16;           // ~0xFFFF'0000
                    // ~0xFFFF'6EF8 
                };
#endif
        public:
            class CoreArchitecture { 
                constexpr CoreArchitecture() = default;
            };
            template<typename T>
            static constexpr Ordinal create(Ordinal cc, bool integerOverflowFlag, bool integerOverflowMask, bool noImpreciseFaults)noexcept {
                using K = std::decay_t<T>;
                if constexpr (std::is_same_v<K, CoreArchitecture>) {
                    auto base = cc;
                    auto shiftedIOF = static_cast<Ordinal>(integerOverflowFlag ? (1 << 8) : 0);
                    auto shiftedIOM = static_cast<Ordinal>(integerOverflowMask ? (1 << 12) : 0);
                    auto shiftedNIF = static_cast<Ordinal>(noImpreciseFaults ? (1 << 15) : 0);
                    return (base | shiftedIOF | shiftedIOM | shiftedNIF) & CoreArchitectureExtractMask;
                } else {
                    static_assert(false_v<T>, "Illegal architecture kind!");
                }
            }
            static constexpr Ordinal extractConditionCode(Ordinal raw) noexcept {
                return raw & 0b111;
            }
            static constexpr bool extractIntegerOverflowFlag(Ordinal raw) noexcept {
                return (raw >> 8) & 1;
            }
            static constexpr bool extractIntegerOverflowMask(Ordinal raw) noexcept {
                return (raw >> 12) & 1;
            }
            static constexpr bool extractNoImpreciseFaults(Ordinal raw) noexcept {
                return (raw >> 15) & 1;
            }
    };
    static_assert(ArithmeticControls::create<ArithmeticControls::CoreArchitecture>(0b111, true, true, true) == ArithmeticControls::CoreArchitectureExtractMask, "create(CoreArchitecture) failed!");

} // end namespace i960
#endif // end I960_ARITHMETIC_CONTROLS_H__
