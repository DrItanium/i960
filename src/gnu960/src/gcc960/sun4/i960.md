;;- Machine description for Intel 80960 chip for GNU C compiler
;;   Copyright (C) 1992 Free Software Foundation, Inc.
;;   Contributed by Steven McGeady, Intel Corp.
;;   Additional work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson
;;   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.

;; This file is part of GNU CC.

;; GNU CC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; GNU CC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU CC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.

;; Insn attributes which describe the i960.

;; cpu type
;; used for instruction scheduling
(define_attr "cpu" "kx,cx,jx,hx"
 (const
  (cond [(symbol_ref "TARGET_C_SERIES") (const_string "cx")
         (symbol_ref "TARGET_J_SERIES") (const_string "jx")
         (symbol_ref "TARGET_H_SERIES") (const_string "hx")]
         (const_string "kx"))))

(define_attr "dcache" "off,on"
  (const
    (cond [(symbol_ref "TARGET_DCACHE") (const_string "on")]
           (const_string "off"))))

(define_attr "type"
  "reglda,move,arith,mult,div,load,store,branch,call,address,compare,fpmove,fpcvt,fpcc,fpadd,fpmul,fpdiv,multi"
  (const_string "arith"))

;; Length (in # of insns).
;;(define_attr "length" ""
;;  (cond [(eq_attr "type" "load")
;;	      (if_then_else (match_operand 1 "symbolic_memory_operand" "")
;;			    (const_int 2)
;;			    (const_int 1))
;;	 (eq_attr "type" "store")
;;	      (if_then_else (match_operand 0 "symbolic_memory_operand" "")
;;			    (const_int 2)
;;			    (const_int 1))
;;	 (eq_attr "type" "address")
;;	      (const_int 2)]
;;	(const_int 1)))

(define_asm_attributes
  [
   (set_attr "type" "multi")])

;; (define_function_unit {name} {num-units} {n-users} {test}
;;                       {ready-delay} {busy-delay} [{conflict-list}])
;;
;; note that the function units are numbered in the order in which
;; they are declared.  The i960 scheduler extension uses the function unit
;; number to sort for superscalar execution.  See I960_* definitions in
;; i_sched.c.  Changing the order or number of the function units will
;; mess things up, unless changes are made there also.

;; Control/Branch format instructions
(define_function_unit "ctrl" 1 0 (eq_attr "type" "branch") 1 0)
(define_function_unit "ctrl" 1 0 (eq_attr "type" "call") 5 0)

;; Memory format instructions
(define_function_unit "mem" 1 2 (and (eq_attr "type" "load")
                                        (eq_attr "dcache" "off")) 5 0)
(define_function_unit "mem" 1 2 (and (eq_attr "type" "load")
                                        (eq_attr "dcache" "on")) 2 0)
(define_function_unit "mem" 1 2 (eq_attr "type" "store") 2 0)
(define_function_unit "mem" 1 2 (eq_attr "type" "address") 1 0)

;; Memory or Reg format instructions
(define_function_unit "both" 1 2 (eq_attr "type" "reglda") 1 0)

;; Reg format instructions
(define_function_unit "reg" 1 2 (eq_attr "type" "arith,move") 1 0)
(define_function_unit "reg" 1 2 (eq_attr "type" "mult") 5 0)
(define_function_unit "reg" 1 2 (eq_attr "type" "div") 35 0)

(define_function_unit "cmp" 1 1 (and (eq_attr "type" "compare")
                                     (eq_attr "cpu" "kx,jx")) 1 0)
(define_function_unit "cmp" 1 1 (and (eq_attr "type" "compare")
                                     (eq_attr "cpu" "hx,cx")) 1 0)

;; Floating point operations.
;; (define_function_unit "fp" 1 2 (eq_attr "type" "fpmove") 5 0)
;; (define_function_unit "fp" 1 2 (eq_attr "type" "fpcvt") 35 0)
;; (define_function_unit "fp" 1 2 (eq_attr "type" "fpcc") 10 0)
;; (define_function_unit "fp" 1 2 (eq_attr "type" "fpadd") 10 0)
;; (define_function_unit "fp" 1 2 (eq_attr "type" "fpmul") 20 0)
;; (define_function_unit "fp" 1 2 (eq_attr "type" "fpdiv") 35 0)


;; Compare instructions.
;; This controls RTL generation and register allocation.

;; We generate RTL for comparisons and branches by having the cmpxx 
;; patterns store away the operands.  Then, the scc and bcc patterns
;; emit RTL for both the compare and the branch.
;;
;; We start with the DEFINE_EXPANDs, then then DEFINE_INSNs to match
;; the patterns.  Finally, we have the DEFINE_SPLITs for some of the scc
;; insns that actually require more than one machine instruction.

;; Put cmpsi first because it is expected to be the most common.

(define_expand "cmpsi"
  [(set (reg:CC 36)
	(compare:CC (match_operand:SI 0 "nonimmediate_operand" "")
		    (match_operand:SI 1 "general_operand" "")))]
  ""
  "
{
  if (1) /* suppress unused code messages */
  {
    i960_compare_op0 = operands[0];
    i960_compare_op1 = operands[1];
    DONE;
  }
}")

(define_expand "cmphi"
  [(set (reg:CC 36)
	(compare:CC (match_operand:HI 0 "nonimmediate_operand" "")
		    (match_operand:HI 1 "general_operand" "")))]
  "TARGET_J_SERIES || TARGET_H_SERIES"
  "
{
  if (1) /* suppress unused code messages */
  {
    i960_compare_op0 = operands[0];
    i960_compare_op1 = operands[1];
    DONE;
  }
}")

(define_expand "cmpqi"
  [(set (reg:CC 36)
	(compare:CC (match_operand:QI 0 "nonimmediate_operand" "")
		    (match_operand:QI 1 "general_operand" "")))]
  "TARGET_J_SERIES || TARGET_H_SERIES"
  "
{
  if (1) /* suppress unused code messages */
  {
    i960_compare_op0 = operands[0];
    i960_compare_op1 = operands[1];
    DONE;
  }
}")

(define_expand "cmpdf"
  [(set (reg:CC 36)
	(compare:CC (match_operand:DF 0 "register_operand" "")
		    (match_operand:DF 1 "nonmemory_operand" "")))]
  ""
  "
{
  if (1) /* suppress unused code messages */
  {
    i960_compare_op0 = operands[0];
    i960_compare_op1 = operands[1];

    if (!TARGET_NUMERICS)
      i960_emit_libcall(COMPARE,CODE_FOR_cmpdf,operands);
    DONE;
  }
}")

(define_expand "cmpsf"
  [(set (reg:CC 36)
	(compare:CC (match_operand:SF 0 "register_operand" "")
		    (match_operand:SF 1 "nonmemory_operand" "")))]
  ""
  "
{
  if (1) /* suppress unused code messages */
  {
    i960_compare_op0 = operands[0];
    i960_compare_op1 = operands[1];

    if (!TARGET_NUMERICS)
      i960_emit_libcall(COMPARE,CODE_FOR_cmpsf,operands);
    DONE;
  }
}")

(define_expand "cmptf"
  [(set (reg:CC 36)
	(compare:CC (match_operand:TF 0 "register_operand" "")
		    (match_operand:TF 1 "nonmemory_operand" "")))]
  ""
  "
{
  if (1) /* suppress unused code messages */
  {
    i960_compare_op0 = operands[0];
    i960_compare_op1 = operands[1];

    if (!TARGET_NUMERICS)
      i960_emit_libcall(COMPARE,CODE_FOR_cmptf,operands);
    DONE;
  }
}")
;;
;; patterns for chkbit cases.
;;
(define_insn ""
  [(set (reg 36)
        (compare (zero_extract:SI (match_operand:SI 0 "register_operand" "d")
                                  (const_int 1)
                                  (match_operand:SI 1 "arith_operand" "dI"))
                 (const_int 0)))]
  "i960_cc_user_eq_neq_p(insn)"
  "*
{
  rtx t = operands[0];
  operands[0] = operands[1];
  operands[1] = t;
  return i960_output_compare(insn, CC_CHKmode, operands);
}"
  [(set_attr "type" "compare")])

;; Now the DEFINE_INSNs for the compare and scc cases.  First the compares.

(define_insn ""
  [(set (reg:CC 36)
	(compare:CC (match_operand:SI 0 "register_operand" "d")
		    (match_operand:SI 1 "nonmemory_operand" "dI")))]
  ""
  "*
{
  return i960_output_compare(insn, CCmode, operands);
}"
  [(set_attr "type" "compare")])

(define_insn ""
  [(set (reg:CC 36)
	(compare:CC (match_operand:HI 0 "register_operand" "d")
		    (match_operand:HI 1 "nonmemory_operand" "dI")))]
  "TARGET_J_SERIES || TARGET_H_SERIES"
  "*
{
  return i960_output_compare(insn, CCmode, operands);
}"
  [(set_attr "type" "compare")])

(define_insn ""
  [(set (reg:CC 36)
	(compare:CC (match_operand:QI 0 "register_operand" "d")
		    (match_operand:QI 1 "nonmemory_operand" "dI")))]
  "TARGET_J_SERIES || TARGET_H_SERIES"
  "*
{
  return i960_output_compare(insn, CCmode, operands);
}"
  [(set_attr "type" "compare")])

(define_insn ""
  [(set (reg:CC_UNS 36)
	(compare:CC_UNS (match_operand:SI 0 "register_operand" "d")
			(match_operand:SI 1 "nonmemory_operand" "dI")))]
  ""
  "*
{
  return i960_output_compare(insn, CC_UNSmode, operands);
}"
  [(set_attr "type" "compare")])

(define_insn ""
  [(set (reg:CC_UNS 36)
	(compare:CC_UNS (match_operand:HI 0 "register_operand" "d")
			(match_operand:HI 1 "nonmemory_operand" "dI")))]
  "TARGET_J_SERIES || TARGET_H_SERIES"
  "*
{
  return i960_output_compare(insn, CC_UNSmode, operands);
}"
  [(set_attr "type" "compare")])

(define_insn ""
  [(set (reg:CC_UNS 36)
	(compare:CC_UNS (match_operand:QI 0 "register_operand" "d")
			(match_operand:QI 1 "nonmemory_operand" "dI")))]
  "TARGET_J_SERIES || TARGET_H_SERIES"
  "*
{
  return i960_output_compare(insn, CC_UNSmode, operands);
}"
  [(set_attr "type" "compare")])

(define_insn ""
  [(set (reg:CC 36)
	(compare:CC (match_operand:DF 0 "register_operand" "tf")
		    (match_operand:DF 1 "nonmemory_operand" "tfGH")))]
  "TARGET_NUMERICS"
  "*
{
  return i960_output_compare(insn, DFmode, operands);
}"
  [(set_attr "type" "fpcc")])

(define_insn ""
  [(set (reg:CC 36)
	(compare:CC (match_operand:SF 0 "register_operand" "df")
		    (match_operand:SF 1 "nonmemory_operand" "dfGH")))]
  "TARGET_NUMERICS"
  "*
{
  return i960_output_compare(insn, SFmode, operands);
}"
  [(set_attr "type" "fpcc")])

(define_insn ""
  [(set (reg:CC 36)
	(compare:CC (match_operand:TF 0 "register_operand" "f")
		    (match_operand:TF 1 "nonmemory_operand" "fGH")))]
  "TARGET_NUMERICS"
  "*
{
  return i960_output_compare(insn, TFmode, operands);
}"
  [(set_attr "type" "fpcc")])

;; Templates to store result of condition.
;; '1' is stored if condition is true.
;; '0' is stored if condition is false.
;; These should use predicate "general_operand", since
;; gcc seems to be creating mem references which use these
;; templates.

;;(define_expand "seq"
;;  [(set (match_operand:SI 0 "general_operand" "=d")
;;	(eq (match_dup 1) (const_int 0)))]
;;  "TARGET_K_SERIES"
;;  "
;;{
;;  operands[1] = gen_compare_reg (EQ, i960_compare_op0, i960_compare_op1);
;;}")
;;
;;(define_expand "sne"
;;  [(set (match_operand:SI 0 "general_operand" "=d")
;;	(ne (match_dup 1) (const_int 0)))]
;;  "TARGET_K_SERIES"
;;  "
;;{
;;  operands[1] = gen_compare_reg (NE, i960_compare_op0, i960_compare_op1);
;;}")
;;
;;(define_expand "sgt"
;;  [(set (match_operand:SI 0 "general_operand" "=d")
;;	(gt (match_dup 1) (const_int 0)))]
;;  "TARGET_K_SERIES"
;;  "
;;{
;;  operands[1] = gen_compare_reg (GT, i960_compare_op0, i960_compare_op1);
;;}")
;;
;;(define_expand "sgtu"
;;  [(set (match_operand:SI 0 "general_operand" "=d")
;;	(gtu (match_dup 1) (const_int 0)))]
;;  "TARGET_K_SERIES"
;;  "
;;{
;;  operands[1] = gen_compare_reg (GTU, i960_compare_op0, i960_compare_op1);
;;}")
;;
;;(define_expand "slt"
;;  [(set (match_operand:SI 0 "general_operand" "=d")
;;	(lt (match_dup 1) (const_int 0)))]
;;  "TARGET_K_SERIES"
;;  "
;;{
;;  operands[1] = gen_compare_reg (LT, i960_compare_op0, i960_compare_op1);
;;}")
;;
;;(define_expand "sltu"
;;  [(set (match_operand:SI 0 "general_operand" "=d")
;;	(ltu (match_dup 1) (const_int 0)))]
;;  "TARGET_K_SERIES"
;;  "
;;{
;;  operands[1] = gen_compare_reg (LTU, i960_compare_op0, i960_compare_op1);
;;}")
;;
;;(define_expand "sge"
;;  [(set (match_operand:SI 0 "general_operand" "=d")
;;	(ge (match_dup 1) (const_int 0)))]
;;  "TARGET_K_SERIES"
;;  "
;;{
;;  operands[1] = gen_compare_reg (GE, i960_compare_op0, i960_compare_op1);
;;}")
;;
;;(define_expand "sgeu"
;;  [(set (match_operand:SI 0 "general_operand" "=d")
;;	(geu (match_dup 1) (const_int 0)))]
;;  "TARGET_K_SERIES"
;;  "
;;{
;;  operands[1] = gen_compare_reg (GEU, i960_compare_op0, i960_compare_op1);
;;}")
;;
;;(define_expand "sle"
;;  [(set (match_operand:SI 0 "general_operand" "=d")
;;	(le (match_dup 1) (const_int 0)))]
;;  "TARGET_K_SERIES"
;;  "
;;{
;;  operands[1] = gen_compare_reg (LE, i960_compare_op0, i960_compare_op1);
;;}")
;;
;;(define_expand "sleu"
;;  [(set (match_operand:SI 0 "general_operand" "=d")
;;	(leu (match_dup 1) (const_int 0)))]
;;  "TARGET_K_SERIES"
;;  "
;;{
;;  operands[1] = gen_compare_reg (LEU, i960_compare_op0, i960_compare_op1);
;;}")
;;
;;(define_insn ""
;;  [(set (match_operand:SI 0 "general_operand" "=d")
;;	(match_operator 1 "comparison_operator" [(reg 36) (const_int 0)]))]
;;  "TARGET_K_SERIES"
;;  "*
;;{
;;  return i960_output_test(operands);
;;}"
;;  [(set_attr "type" "compare")])

;; Conditional add instruction
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (if_then_else:SI (match_operator 1 "comparison_operator"
                                      [(reg 36) (const_int 0)])
                     (plus:SI (match_operand:SI 2 "nonmemory_operand" "%dI")
                              (match_operand:SI 3 "nonmemory_operand" "dIK"))
                     (match_operand:SI 4 "nonmemory_operand" "0")))]
  "(TARGET_J_SERIES || TARGET_H_SERIES) &&
    (GET_CODE(operands[3]) != CONST_INT ||
     (INTVAL(operands[3]) >= -31 && INTVAL(operands[3]) <= 31))"
  "*
  {
    char * opc = \"addo\";
    if (GET_CODE(operands[3]) == CONST_INT && INTVAL(operands[3]) < 0)
    {
      operands[3] = GEN_INT(-INTVAL(operands[3]));
      opc = \"subo\";
    }
    return i960_output_pred_insn(opc, 0, operands);
  }"
)

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (if_then_else:SI (match_operator 1 "comparison_operator"
                                      [(reg 36) (const_int 0)])
                     (match_operand:SI 2 "nonmemory_operand" "0")
                     (plus:SI (match_operand:SI 3 "nonmemory_operand" "%dI")
                              (match_operand:SI 4 "nonmemory_operand" "dIK"))))]
  "(TARGET_J_SERIES || TARGET_H_SERIES) &&
    (GET_CODE(operands[4]) != CONST_INT ||
     (INTVAL(operands[4]) >= -31 && INTVAL(operands[4]) <= 31))"
  "*
  {
    rtx tmp = operands[2];
    char * opc = \"addo\";
    operands[2] = operands[3];
    operands[3] = operands[4];
    operands[4] = tmp;
    if (GET_CODE(operands[3]) == CONST_INT && INTVAL(operands[3]) < 0)
    {
      operands[3] = GEN_INT(-INTVAL(operands[3]));
      opc = \"subo\";
    }
    return i960_output_pred_insn(opc, 1, operands);
  }"
)

;; Conditional subtract instruction
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (if_then_else:SI (match_operator 1 "comparison_operator"
                                      [(reg 36) (const_int 0)])
                      (minus:SI (match_operand:SI 2 "nonmemory_operand" "dI")
                                (match_operand:SI 3 "nonmemory_operand" "dI"))
                      (match_operand:SI 4 "nonmemory_operand" "0")))]
  "TARGET_J_SERIES || TARGET_H_SERIES"
  "*
  {
    return i960_output_pred_insn(\"subo\", 0, operands);
  }"
)

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (if_then_else:SI (match_operator 1 "comparison_operator"
                                      [(reg 36) (const_int 0)])
                     (match_operand:SI 2 "nonmemory_operand" "0")
                     (minus:SI (match_operand:SI 3 "nonmemory_operand" "dI")
                               (match_operand:SI 4 "nonmemory_operand" "dI"))))]
  "TARGET_J_SERIES || TARGET_H_SERIES"
  "*
  {
    rtx tmp = operands[2];
    operands[2] = operands[3];
    operands[3] = operands[4];
    operands[4] = tmp;
    return i960_output_pred_insn(\"subo\", 1, operands);
  }"
)

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (if_then_else:SI (match_operator 1 "comparison_operator"
                                      [(reg 36) (const_int 0)])
                      (neg:SI (match_operand:SI 2 "nonmemory_operand" "dI"))
                      (match_operand:SI 3 "nonmemory_operand" "0")))]
  "TARGET_J_SERIES || TARGET_H_SERIES"
  "*
  {
    operands[3] = operands[2];
    operands[2] = const0_rtx;
    return i960_output_pred_insn(\"subo\", 0, operands);
  }"
)

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (if_then_else:SI (match_operator 1 "comparison_operator"
                                      [(reg 36) (const_int 0)])
                      (match_operand:SI 2 "nonmemory_operand" "0")
                      (neg:SI (match_operand:SI 3 "nonmemory_operand" "dI"))))]
  "TARGET_J_SERIES || TARGET_H_SERIES"
  "*
  {
    operands[2] = const0_rtx;
    return i960_output_pred_insn(\"subo\", 1, operands);
  }"
)

;; Conditional move instruction
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (if_then_else:SI (match_operator 1 "comparison_operator"
                                      [(reg 36) (const_int 0)])
                      (match_operand:SI 2 "register_operand" "0")
                      (match_operand:SI 3 "immediate_operand" "n")))]
  "(TARGET_J_SERIES || TARGET_H_SERIES) &&
   (GET_CODE(operands[3]) == CONST_INT &&
    ((INTVAL(operands[3]) >= -31 && INTVAL(operands[3]) < 0) ||
     (INTVAL(operands[3]) >= 32 && INTVAL(operands[3]) < 63))) &&
    REGNO(operands[0]) == REGNO(operands[2])"
  "*
  {
    if (INTVAL(operands[3]) > 0) 
    {
      operands[3] = GEN_INT(INTVAL(operands[3])-31);
      operands[2] = GEN_INT(31);
      return i960_output_pred_insn(\"addo\", 1, operands);
    }
    else
    {
      operands[3] = GEN_INT(-INTVAL(operands[3]));
      operands[2] = const0_rtx;
      return i960_output_pred_insn(\"subo\", 1, operands);
    }
  }"
)

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (if_then_else:SI (match_operator 1 "comparison_operator"
                                      [(reg 36) (const_int 0)])
                      (match_operand:SI 2 "immediate_operand" "n")
                      (match_operand:SI 3 "register_operand" "0")))]
  "(TARGET_J_SERIES || TARGET_H_SERIES) &&
   (GET_CODE(operands[2]) == CONST_INT &&
    ((INTVAL(operands[2]) >= -31 && INTVAL(operands[2]) < 0) ||
     (INTVAL(operands[2]) >= 32 && INTVAL(operands[2]) < 63))) &&
   REGNO(operands[0]) == REGNO(operands[3])"
  "*
  {
    if (INTVAL(operands[2]) > 0) 
    {
      operands[3] = GEN_INT(INTVAL(operands[2])-31);
      operands[2] = GEN_INT(31);
      return i960_output_pred_insn(\"addo\", 0, operands);
    }
    else
    {
      operands[3] = GEN_INT(-INTVAL(operands[2]));
      operands[2] = const0_rtx;
      return i960_output_pred_insn(\"subo\", 0, operands);
    }
  }"
)

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (if_then_else:SI (match_operator 1 "comparison_operator"
                                      [(reg 36) (const_int 0)])
                      (match_operand:SI 2 "nonmemory_operand" "dI")
                      (match_operand:SI 3 "nonmemory_operand" "dI")))]
  "TARGET_J_SERIES || TARGET_H_SERIES"
  "*
  {
    return i960_output_pred_insn(\"sel\", 0, operands);
  }"
)


;; These control RTL generation for conditional jump insns
;; and match them for register allocation.

(define_expand "beq"
  [(set (pc)
	(if_then_else (eq (match_dup 1)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{ operands[1] = gen_compare_reg (EQ, i960_compare_op0, i960_compare_op1); }")

(define_expand "bne"
  [(set (pc)
	(if_then_else (ne (match_dup 1)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{ operands[1] = gen_compare_reg (NE, i960_compare_op0, i960_compare_op1); }")

(define_expand "bgt"
  [(set (pc)
	(if_then_else (gt (match_dup 1)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{ operands[1] = gen_compare_reg (GT, i960_compare_op0, i960_compare_op1); }")

(define_expand "bgtu"
  [(set (pc)
	(if_then_else (gtu (match_dup 1)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{ operands[1] = gen_compare_reg (GTU, i960_compare_op0, i960_compare_op1); }")

(define_expand "blt"
  [(set (pc)
	(if_then_else (lt (match_dup 1)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{ operands[1] = gen_compare_reg (LT, i960_compare_op0, i960_compare_op1); }")

(define_expand "bltu"
  [(set (pc)
	(if_then_else (ltu (match_dup 1)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{ operands[1] = gen_compare_reg (LTU, i960_compare_op0, i960_compare_op1); }")

(define_expand "bge"
  [(set (pc)
	(if_then_else (ge (match_dup 1)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{ operands[1] = gen_compare_reg (GE, i960_compare_op0, i960_compare_op1); }")

(define_expand "bgeu"
  [(set (pc)
	(if_then_else (geu (match_dup 1)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{ operands[1] = gen_compare_reg (GEU, i960_compare_op0, i960_compare_op1); }")

(define_expand "ble"
  [(set (pc)
	(if_then_else (le (match_dup 1)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{ operands[1] = gen_compare_reg (LE, i960_compare_op0, i960_compare_op1); }")

(define_expand "bleu"
  [(set (pc)
	(if_then_else (leu (match_dup 1)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{ operands[1] = gen_compare_reg (LEU, i960_compare_op0, i960_compare_op1); }")

;;
;; Now the normal branch insns (forward and reverse).
;;

(define_insn ""
  [(set (pc)
	(if_then_else (match_operator 0 "comparison_operator"
				      [(reg 36) (const_int 0)])
		      (pc)
		      (label_ref (match_operand 1 "" ""))))]
  ""
  "*
{
  return i960_output_cmp_branch(insn, operands, 1);
}"
  [(set_attr "type" "branch")])

(define_insn ""
  [(set (pc)
	(if_then_else (match_operator 0 "comparison_operator"
				      [(reg 36) (const_int 0)])
		      (label_ref (match_operand 1 "" ""))
		      (pc)))]
  ""
  "*
{
  return i960_output_cmp_branch(insn, operands, 0);
}"
  [(set_attr "type" "branch")])

(define_insn ""
  [(set (pc)
        (if_then_else
         (match_operator 0 "comparison_operator"
                         [(zero_extract:SI
                            (match_operand:SI 1 "register_operand" "d")
                            (const_int 1)
                            (match_operand:SI 2 "arith_operand" "dI"))
                          (const_int 0)])
         (label_ref (match_operand 3 "" ""))
         (pc)))]
  "TARGET_CMPBRANCH &&
   (GET_CODE(operands[0]) == EQ || GET_CODE(operands[0]) == NE)"
  "*
  {
    PUT_MODE(operands[0], CC_CHKmode);
    return \"bb%C0	%2,%1,%l3\";
  }"
  [(set_attr "type" "branch")])

(define_insn ""
  [(set (pc)
        (if_then_else
         (match_operator 0 "comparison_operator"
                         [(zero_extract:SI
                            (match_operand:SI 1 "register_operand" "d")
                            (const_int 1)
                            (match_operand:SI 2 "arith_operand" "dI"))
                          (const_int 0)])
         (pc)
         (label_ref (match_operand 3 "" ""))))]
  "TARGET_CMPBRANCH &&
   (GET_CODE(operands[0]) == EQ || GET_CODE(operands[0]) == NE)"
  "*
  {
    PUT_MODE(operands[0], CC_CHKmode);
    return \"bb%I0	%2,%1,%l3\";
  }"
  [(set_attr "type" "branch")])

(define_insn ""
  [(set (pc)
        (if_then_else
         (match_operator 0 "comparison_operator"
                         [(match_operand:SI 1 "register_operand" "d")
                          (match_operand:SI 2 "nonmemory_operand" "dI")])
         (label_ref (match_operand 3 "" ""))
         (pc)))]
  "TARGET_CMPBRANCH"
  "cmp%S0%B0%R0	%2,%1,%l3"
  [(set_attr "type" "branch")])

(define_insn ""
  [(set (pc)
        (if_then_else
         (match_operator 0 "comparison_operator"
                         [(match_operand:SI 1 "register_operand" "d")
                          (match_operand:SI 2 "nonmemory_operand" "dI")])
         (pc)
         (label_ref (match_operand 3 "" ""))))]
  "TARGET_CMPBRANCH"
  "cmp%S0%B0%X0	%2,%1,%l3"
  [(set_attr "type" "branch")])

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "=d")
        (plus:SI (match_operand:SI 1 "register_operand" "d")
                 (match_operand:SI 2 "immediate_operand" "i")))
   (set (reg:CC 36)
        (compare:CC (match_dup 0)
                    (match_operand:SI 3 "immediate_operand" "i")))]
  "((((INTVAL(operands[2]) == 1 || INTVAL(operands[2]) == -1)) &&
     ((INTVAL(operands[3]) - INTVAL(operands[2])) >= 0) &&
     ((INTVAL(operands[3]) - INTVAL(operands[2])) <= 31)) &&
    i960_cc_user_eq_neq_p(insn))"
  "*
  {
    operands[3] = GEN_INT(INTVAL(operands[3])-INTVAL(operands[2]));
    i960_need_compare = 0;
    i960_cmp_mode = CCmode;
    if (INTVAL(operands[2]) == 1)
      return \"cmpinci	%3,%1,%0\";
    else
      return \"cmpdeci	%3,%1,%0\";
  }"
)

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "=d")
        (plus:SI (match_operand:SI 1 "register_operand" "d")
                 (match_operand:SI 2 "immediate_operand" "i")))
   (set (reg:CC_UNS 36)
        (compare:CC_UNS (match_dup 0)
                        (match_operand:SI 3 "immediate_operand" "i")))]
  "((((INTVAL(operands[2]) == 1 || INTVAL(operands[2]) == -1)) &&
     ((INTVAL(operands[3]) - INTVAL(operands[2])) >= 0) &&
     ((INTVAL(operands[3]) - INTVAL(operands[2])) <= 31)) &&
    i960_cc_user_eq_neq_p(insn))"
  "*
  {
    operands[3] = GEN_INT(INTVAL(operands[3])-INTVAL(operands[2]));
    i960_need_compare = 0;
    i960_cmp_mode = CC_UNSmode;
    if (INTVAL(operands[2]) == 1)
      return \"cmpinco	%3,%1,%0\";
    else
      return \"cmpdeco	%3,%1,%0\";
  }"
)

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "=d")
        (minus:SI (match_operand:SI 1 "register_operand" "d")
                  (match_operand:SI 2 "immediate_operand" "i")))
   (set (reg:CC 36)
        (compare:CC (match_dup 0)
                    (match_operand:SI 3 "immediate_operand" "i")))]
  "((((INTVAL(operands[2]) == 1 || INTVAL(operands[2]) == -1)) &&
     ((INTVAL(operands[3]) + INTVAL(operands[2])) >= 0) &&
     ((INTVAL(operands[3]) + INTVAL(operands[2])) <= 31)) &&
    i960_cc_user_eq_neq_p(insn))"
  "*
  {
    operands[3] = GEN_INT(INTVAL(operands[3])+INTVAL(operands[2]));
    i960_need_compare = 0;
    i960_cmp_mode = CCmode;
    if (INTVAL(operands[2]) == 1)
      return \"cmpdeci	%3,%1,%0\";
    else
      return \"cmpinci	%3,%1,%0\";
  }"
)

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "=d")
        (minus:SI (match_operand:SI 1 "register_operand" "d")
                  (match_operand:SI 2 "immediate_operand" "i")))
   (set (reg:CC_UNS 36)
        (compare:CC_UNS (match_dup 0)
                        (match_operand:SI 3 "immediate_operand" "i")))]
  "((((INTVAL(operands[2]) == 1 || INTVAL(operands[2]) == -1)) &&
     ((INTVAL(operands[3]) + INTVAL(operands[2])) >= 0) &&
     ((INTVAL(operands[3]) + INTVAL(operands[2])) <= 31)) &&
    i960_cc_user_eq_neq_p(insn))"
  "*
  {
    operands[3] = GEN_INT(INTVAL(operands[3])+INTVAL(operands[2]));
    i960_need_compare = 0;
    i960_cmp_mode = CC_UNSmode;
    if (INTVAL(operands[2]) == 1)
      return \"cmpdeco	%3,%1,%0\";
    else
      return \"cmpinco	%3,%1,%0\";
  }"
)

;; Normal move instructions.
;; This code is based on the sparc machine desciption.

(define_split
  [(set (match_operand:SI 0 "register_operand" "")
        (sign_extend:SI
          (mem:QI (plus:SI (match_operand:SI 1 "register_operand" "")
                           (match_operand:SI 2 "immediate_operand" "")))))]
  "(reload_completed == 0 && !flag_space_opt &&
    TARGET_H_SERIES && INSN_EXPECT(insn) > (PROB_BASE * 300) &&
    (max_regno > max_reg_num()+1) &&
    GET_CODE(operands[2]) == CONST_INT &&
    INTVAL(operands[2]) >= -31 &&
    INTVAL(operands[2]) <= 4095)"
  [(set (match_dup 3) (plus:SI (match_dup 1) (match_dup 2)))
   (set (match_dup 0) (sign_extend:SI (mem:QI (match_dup 3))))]
  "{operands[3] = gen_reg_rtx(Pmode);}")

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))
   (set (match_operand:SI 3 "register_operand" "")
        (sign_extend:SI (mem:QI (match_dup 0))))]
  "dead_or_set_p(insn, operands[0])"
  "*
{
  operands[0] = gen_rtx(MEM, QImode,
                        gen_rtx(PLUS, SImode, operands[1], operands[2]));
  return \"ldib\\t%0,%3\";
}")

(define_split
  [(set (match_operand:SI 0 "register_operand" "")
        (zero_extend:SI
          (mem:QI (plus:SI (match_operand:SI 1 "register_operand" "")
                           (match_operand:SI 2 "immediate_operand" "")))))]
  "(reload_completed == 0 && !flag_space_opt &&
    TARGET_H_SERIES && INSN_EXPECT(insn) > (PROB_BASE * 300) &&
    (max_regno > max_reg_num()+1) &&
    GET_CODE(operands[2]) == CONST_INT &&
    INTVAL(operands[2]) >= -31 &&
    INTVAL(operands[2]) <= 4095)"
  [(set (match_dup 3) (plus:SI (match_dup 1) (match_dup 2)))
   (set (match_dup 0) (zero_extend:SI (mem:QI (match_dup 3))))]
  "{operands[3] = gen_reg_rtx(Pmode);}")

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))
   (set (match_operand:SI 3 "register_operand" "")
        (zero_extend:SI (mem:QI (match_dup 0))))]
  "dead_or_set_p(insn, operands[0])"
  "*
{
  operands[0] = gen_rtx(MEM, QImode,
                        gen_rtx(PLUS, SImode, operands[1], operands[2]));
  return \"ldob\\t%0,%3\";
}")

(define_split
  [(set (match_operand:SI 0 "register_operand" "")
        (sign_extend:SI
          (mem:HI (plus:SI (match_operand:SI 1 "register_operand" "")
                           (match_operand:SI 2 "immediate_operand" "")))))]
  "(reload_completed == 0 && !flag_space_opt &&
    TARGET_H_SERIES && INSN_EXPECT(insn) > (PROB_BASE * 300) &&
    (max_regno > max_reg_num()+1) &&
    GET_CODE(operands[2]) == CONST_INT &&
    INTVAL(operands[2]) >= -31 &&
    INTVAL(operands[2]) <= 4095)"
  [(set (match_dup 3) (plus:SI (match_dup 1) (match_dup 2)))
   (set (match_dup 0) (sign_extend:SI (mem:HI (match_dup 3))))]
  "{operands[3] = gen_reg_rtx(Pmode);}")

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))
   (set (match_operand:SI 3 "register_operand" "")
        (sign_extend:SI (mem:HI (match_dup 0))))]
  "dead_or_set_p(insn, operands[0])"
  "*
{
  operands[0] = gen_rtx(MEM, QImode,
                        gen_rtx(PLUS, SImode, operands[1], operands[2]));
  return \"ldis\\t%0,%3\";
}")

(define_split
  [(set (match_operand:SI 0 "register_operand" "")
        (zero_extend:SI
          (mem:HI (plus:SI (match_operand:SI 1 "register_operand" "")
                           (match_operand:SI 2 "immediate_operand" "")))))]
  "(reload_completed == 0 && !flag_space_opt &&
    TARGET_H_SERIES && INSN_EXPECT(insn) > (PROB_BASE * 300) &&
    (max_regno > max_reg_num()+1) &&
    GET_CODE(operands[2]) == CONST_INT &&
    INTVAL(operands[2]) >= -31 &&
    INTVAL(operands[2]) <= 4095)"
  [(set (match_dup 3) (plus:SI (match_dup 1) (match_dup 2)))
   (set (match_dup 0) (zero_extend:SI (mem:HI (match_dup 3))))]
  "{operands[3] = gen_reg_rtx(Pmode);}")

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))
   (set (match_operand:SI 3 "register_operand" "")
        (zero_extend:SI (mem:HI (match_dup 0))))]
  "dead_or_set_p(insn, operands[0])"
  "*
{
  operands[0] = gen_rtx(MEM, QImode,
                        gen_rtx(PLUS, SImode, operands[1], operands[2]));
  return \"ldos\\t%0,%3\";
}")

(define_split
  [(set (match_operand:SI 0 "register_operand" "")
        (mem:SI (plus:SI (match_operand:SI 1 "register_operand" "")
                         (match_operand:SI 2 "immediate_operand" ""))))]
  "(reload_completed == 0 && !flag_space_opt &&
    TARGET_H_SERIES && INSN_EXPECT(insn) > (PROB_BASE * 300) &&
    (max_regno > max_reg_num()+1) &&
    GET_CODE(operands[2]) == CONST_INT &&
    INTVAL(operands[2]) >= -31 &&
    INTVAL(operands[2]) <= 4095)"
  [(set (match_dup 3) (plus:SI (match_dup 1) (match_dup 2)))
   (set (match_dup 0) (mem:SI (match_dup 3)))]
  "{operands[3] = gen_reg_rtx(Pmode);}")

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))
   (set (match_operand:SI 3 "register_operand" "")
        (mem:SI (match_dup 0)))]
  "dead_or_set_p(insn, operands[0])"
  "*
{
  operands[0] = gen_rtx(MEM, SImode,
                        gen_rtx(PLUS, SImode, operands[1], operands[2]));
  return \"ld\\t%0,%3\";
}")

(define_split
  [(set (match_operand:DI 0 "register_operand" "")
        (mem:DI (plus:SI (match_operand:SI 1 "register_operand" "")
                         (match_operand:SI 2 "immediate_operand" ""))))]
  "(reload_completed == 0 && !flag_space_opt &&
    TARGET_H_SERIES && INSN_EXPECT(insn) > (PROB_BASE * 300) &&
    (max_regno > max_reg_num()+1) &&
    GET_CODE(operands[2]) == CONST_INT &&
    INTVAL(operands[2]) >= -31 &&
    INTVAL(operands[2]) <= 4095)"
  [(set (match_dup 3) (plus:SI (match_dup 1) (match_dup 2)))
   (set (match_dup 0) (mem:DI (match_dup 3)))]
  "{operands[3] = gen_reg_rtx(Pmode);}")

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))
   (set (match_operand:DI 3 "register_operand" "")
        (mem:DI (match_dup 0)))]
  "dead_or_set_p(insn, operands[0])"
  "*
{
  operands[0] = gen_rtx(MEM, DImode,
                        gen_rtx(PLUS, SImode, operands[1], operands[2]));
  return \"ldl\\t%0,%3\";
}")

(define_split
  [(set (match_operand:TI 0 "register_operand" "")
        (mem:TI (plus:SI (match_operand:SI 1 "register_operand" "")
                         (match_operand:SI 2 "immediate_operand" ""))))]
  "(reload_completed == 0 && !flag_space_opt &&
    TARGET_H_SERIES && INSN_EXPECT(insn) > (PROB_BASE * 300) &&
    (max_regno > max_reg_num()+1) &&
    GET_CODE(operands[2]) == CONST_INT &&
    INTVAL(operands[2]) >= -31 &&
    INTVAL(operands[2]) <= 4095)"
  [(set (match_dup 3) (plus:SI (match_dup 1) (match_dup 2)))
   (set (match_dup 0) (mem:TI (match_dup 3)))]
  "{operands[3] = gen_reg_rtx(Pmode);}")

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))
   (set (match_operand:TI 3 "register_operand" "")
        (mem:TI (match_dup 0)))]
  "dead_or_set_p(insn, operands[0])"
  "*
{
  operands[0] = gen_rtx(MEM, TImode,
                        gen_rtx(PLUS, SImode, operands[1], operands[2]));
  return \"ldq\\t%0,%3\";
}")

(define_split
  [(set (mem:QI (plus:SI (match_operand:SI 0 "register_operand" "")
                         (match_operand:SI 1 "immediate_operand" "")))
        (match_operand:QI 2 "register_operand" ""))]
  "(reload_completed == 0 && !flag_space_opt &&
    TARGET_H_SERIES && INSN_EXPECT(insn) > (PROB_BASE * 300) &&
    (max_regno > max_reg_num()+1) &&
    GET_CODE(operands[1]) == CONST_INT &&
    INTVAL(operands[1]) >= -31 &&
    INTVAL(operands[1]) <= 4095)"
  [(set (match_dup 3) (plus:SI (match_dup 0) (match_dup 1)))
   (set (mem:QI (match_dup 3)) (match_dup 2))]
  "{operands[3] = gen_reg_rtx(Pmode);}")

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))
   (set (mem:QI (match_dup 0))
        (match_operand:QI 3 "register_operand" ""))]
  "dead_or_set_p(insn, operands[0])"
  "*
{
  operands[0] = gen_rtx(MEM, QImode,
                        gen_rtx(PLUS, SImode, operands[1], operands[2]));
  return \"stob\\t%3,%0\";
}")

(define_split
  [(set (mem:HI (plus:SI (match_operand:SI 0 "register_operand" "")
                         (match_operand:SI 1 "immediate_operand" "")))
        (match_operand:HI 2 "register_operand" ""))]
  "(reload_completed == 0 && !flag_space_opt &&
    TARGET_H_SERIES && INSN_EXPECT(insn) > (PROB_BASE * 300) &&
    (max_regno > max_reg_num()+1) &&
    GET_CODE(operands[1]) == CONST_INT &&
    INTVAL(operands[1]) >= -31 &&
    INTVAL(operands[1]) <= 4095)"
  [(set (match_dup 3) (plus:SI (match_dup 0) (match_dup 1)))
   (set (mem:HI (match_dup 3)) (match_dup 2))]
  "{operands[3] = gen_reg_rtx(Pmode);}")

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))
   (set (mem:HI (match_dup 0))
        (match_operand:HI 3 "register_operand" ""))]
  "dead_or_set_p(insn, operands[0])"
  "*
{
  operands[0] = gen_rtx(MEM, HImode,
                        gen_rtx(PLUS, SImode, operands[1], operands[2]));
  return \"stos\\t%3,%0\";
}")

(define_split
  [(set (mem:SI (plus:SI (match_operand:SI 0 "register_operand" "")
                         (match_operand:SI 1 "immediate_operand" "")))
        (match_operand:SI 2 "register_operand" ""))]
  "(reload_completed == 0 && !flag_space_opt &&
    TARGET_H_SERIES && INSN_EXPECT(insn) > (PROB_BASE * 300) &&
    (max_regno > max_reg_num()+1) &&
    GET_CODE(operands[1]) == CONST_INT &&
    INTVAL(operands[1]) >= -31 &&
    INTVAL(operands[1]) <= 4095)"
  [(set (match_dup 3) (plus:SI (match_dup 0) (match_dup 1)))
   (set (mem:SI (match_dup 3)) (match_dup 2))]
  "{operands[3] = gen_reg_rtx(Pmode);}")

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))
   (set (mem:SI (match_dup 0))
        (match_operand:SI 3 "register_operand" ""))]
  "dead_or_set_p(insn, operands[0])"
  "*
{
  operands[0] = gen_rtx(MEM, SImode,
                        gen_rtx(PLUS, SImode, operands[1], operands[2]));
  return \"st\\t%3,%0\";
}")

(define_split
  [(set (mem:DI (plus:SI (match_operand:SI 0 "register_operand" "")
                         (match_operand:SI 1 "immediate_operand" "")))
        (match_operand:DI 2 "register_operand" ""))]
  "(reload_completed == 0 && !flag_space_opt &&
    TARGET_H_SERIES && INSN_EXPECT(insn) > (PROB_BASE * 300) &&
    (max_regno > max_reg_num()+1) &&
    GET_CODE(operands[1]) == CONST_INT &&
    INTVAL(operands[1]) >= -31 &&
    INTVAL(operands[1]) <= 4095)"
  [(set (match_dup 3) (plus:SI (match_dup 0) (match_dup 1)))
   (set (mem:DI (match_dup 3)) (match_dup 2))]
  "{operands[3] = gen_reg_rtx(Pmode);}")

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))
   (set (mem:DI (match_dup 0))
        (match_operand:DI 3 "register_operand" ""))]
  "dead_or_set_p(insn, operands[0])"
  "*
{
  operands[0] = gen_rtx(MEM, DImode,
                        gen_rtx(PLUS, SImode, operands[1], operands[2]));
  return \"stl\\t%3,%0\";
}")

(define_split
  [(set (mem:TI (plus:SI (match_operand:SI 0 "register_operand" "")
                         (match_operand:SI 1 "immediate_operand" "")))
        (match_operand:TI 2 "register_operand" ""))]
  "(reload_completed == 0 && !flag_space_opt &&
    TARGET_H_SERIES && INSN_EXPECT(insn) > (PROB_BASE * 300) &&
    (max_regno > max_reg_num()+1) &&
    GET_CODE(operands[1]) == CONST_INT &&
    INTVAL(operands[1]) >= -31 &&
    INTVAL(operands[1]) <= 4095)"
  [(set (match_dup 3) (plus:SI (match_dup 0) (match_dup 1)))
   (set (mem:TI (match_dup 3)) (match_dup 2))]
  "{operands[3] = gen_reg_rtx(Pmode);}")

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))
   (set (mem:TI (match_dup 0))
        (match_operand:TI 3 "register_operand" ""))]
  "dead_or_set_p(insn, operands[0])"
  "*
{
  operands[0] = gen_rtx(MEM, TImode,
                        gen_rtx(PLUS, SImode, operands[1], operands[2]));
  return \"stq\\t%3,%0\";
}")

(define_expand "movsi"
  [(set (match_operand:SI 0 "move_operand" "")
	(match_operand:SI 1 "move_operand" ""))]
  ""
  "
{
  if (emit_move_sequence (operands, SImode))
    DONE;
}")

;; The store case can not be separate, because reload may convert a register
;; to register move insn to a store (or load) insn without rerecognizing
;; the insn.

(define_insn ""
  [(set (match_operand:SI 0 "move_operand" "=d,d,d,d,m,   d,uvwxyz,u,v,w,x,y,z")
	(match_operand:SI 1 "move_operand" "dI,*f,i,m,dJ, uvwxyz,d,u,v,w,x,y,z"))]
  "(GET_CODE(operands[0]) != MEM ||
   (GET_CODE(operands[1]) != MEM &&
    (!immediate_operand(operands[1], SImode) ||
     operands[1] == const0_rtx || !const_fixup_happened)))"
  "*
{
  switch (which_alternative)
    {
    default:
    { extern char* i960_out_cop_move();
      return i960_out_cop_move (operands);
    }
    case 0:
      if (i960_last_insn_type == I_TYPE_REG &&
          (TARGET_C_SERIES || TARGET_H_SERIES)) 
	{
	  if (GET_CODE (operands[1]) == REG ||
              GET_CODE (operands[1]) == SUBREG)
	    return \"lda	(%1),%0\";
	  else
	    return \"lda	%1,%0\";
	}
      return \"mov	%1,%0\";
    case 1:
      return \"movr	%1,%0\";
    case 2:
      return i960_output_ldconst (operands[0], operands[1]);
    case 3:
      return \"ld	%1,%0\";
    case 4:
      if (operands[1] == const0_rtx)
        return \"st	g14,%0\";
      return \"st	%1,%0\";      
    }
}"
  [(set_attr "type" "reglda,move,reglda,load,store,move,move,move,move,move,move,move,move") ])

(define_expand "movhi"
  [(set (match_operand:HI 0 "move_operand" "")
	(match_operand:HI 1 "move_operand" ""))]
  ""
  "
{
  if (emit_move_sequence (operands, HImode))
    DONE;
}")

;; The store case can not be separate.  See above.
(define_insn ""
  [(set (match_operand:HI 0 "move_operand" "=d,d,d,m,  d,uvwxyz,u,v,w,x,y,z")
	(match_operand:HI 1 "move_operand" "dI,i,m,dJ, uvwxyz,d,u,v,w,x,y,z"))]
  "(GET_CODE(operands[0]) != MEM || GET_CODE(operands[1]) != MEM)"
  "*
{
  switch (which_alternative)
    {
    default:
    { extern char* i960_out_cop_move();
      return i960_out_cop_move (operands);
    }
    case 0:
      if (i960_last_insn_type == I_TYPE_REG &&
          (TARGET_C_SERIES || TARGET_H_SERIES))
	{
	  if (GET_CODE (operands[1]) == REG)
	    return \"lda	(%1),%0\";
	  else
	    return \"lda	%1,%0\";
	}
      return \"mov	%1,%0\";
    case 1:
      return i960_output_ldconst (operands[0], operands[1]);
    case 2:
      return \"ldos	%1,%0\";
    case 3:
      if (operands[1] == const0_rtx)
        return \"stos	g14,%0\";
      return \"stos	%1,%0\";
    }
}"
  [(set_attr "type" "reglda,reglda,load,store,move,move,move,move,move,move,move,move") ])

(define_expand "movqi"
  [(set (match_operand:QI 0 "move_operand" "")
	(match_operand:QI 1 "move_operand" ""))]
  ""
  "
{
  if (emit_move_sequence (operands, QImode))
    DONE;
}")

;; The store case can not be separate.  See comment above.
(define_insn ""
  [(set (match_operand:QI 0 "move_operand" "=d,d,d,m,  d,uvwxyz,u,v,w,x,y,z")
	(match_operand:QI 1 "move_operand" "dI,i,m,dJ, uvwxyz,d,u,v,w,x,y,z"))]
  "(GET_CODE(operands[0]) != MEM || GET_CODE(operands[1]) != MEM)"
  "*
{
  switch (which_alternative)
    {
    default:
    { extern char* i960_out_cop_move();
      return i960_out_cop_move (operands);
    }
    case 0:
      if (i960_last_insn_type == I_TYPE_REG &&
          (TARGET_C_SERIES || TARGET_H_SERIES))
	{
	  if (GET_CODE (operands[1]) == REG)
	    return \"lda	(%1),%0\";
	  else
	    return \"lda	%1,%0\";
	}
      return \"mov	%1,%0\";
    case 1:
      return i960_output_ldconst (operands[0], operands[1]);
    case 2:
      return \"ldob	%1,%0\";
    case 3:
      if (operands[1] == const0_rtx)
        return \"stob	g14,%0\";
      return \"stob	%1,%0\";
    }
}"
  [(set_attr "type" "reglda,reglda,load,store,move,move,move,move,move,move,move,move") ])

(define_expand "movdi"
  [(set (match_operand:DI 0 "move_operand" "")
	(match_operand:DI 1 "move_operand" ""))]
  ""
  "
{
  if (emit_move_sequence (operands, DImode))
    DONE;
}")

;; The store case can not be separate.  See comment above.
(define_insn ""
  [(set (match_operand:DI 0 "move_operand" "=t,t,t,t,m")
	(match_operand:DI 1 "move_operand" "tI,*f,i,m,t"))]
  "(GET_CODE(operands[0]) != MEM || GET_CODE(operands[1]) != MEM)"
  "*
{
  switch (which_alternative)
    {
    case 0:
      return i960_out_movl(operands[0], operands[1]);
    case 1:
      return \"movrl	%1,%0\";
    case 2:
      return i960_output_ldconst (operands[0], operands[1]);
    case 3:
      return i960_out_ldl(operands[0], operands[1]);
    case 4:
      return i960_out_stl(operands[0], operands[1]);
    }
}"
  [(set_attr "type" "move,move,reglda,load,store")])

(define_split
  [(set (match_operand:DI 0 "register_operand" "")
        (match_operand:DI 1 "register_operand" ""))]
  "reload_completed && TARGET_J_SERIES &&
   GET_CODE (operands[0]) == REG && REGNO(operands[0]) < 32 &&
   GET_CODE (operands[1]) == REG && REGNO(operands[1]) < 32"

  [(set (subreg:SI (match_dup 0) 0) (subreg:SI (match_dup 1) 0))
   (set (subreg:SI (match_dup 0) 1) (subreg:SI (match_dup 1) 1))]
  "")

(define_expand "movti"
  [(set (match_operand:TI 0 "move_operand" "")
	(match_operand:TI 1 "move_operand" ""))]
  ""
  "
{
  if (emit_move_sequence (operands, TImode))
    DONE;
}")

;; The store case can not be separate.  See comment above.
(define_insn ""
  [(set (match_operand:TI 0 "move_operand" "=q,q,q,m")
	(match_operand:TI 1 "move_operand" "qI,i,m,q"))]
  "(GET_CODE(operands[0]) != MEM || GET_CODE(operands[1]) != MEM)"
  "*
{
  switch (which_alternative)
    {
    case 0:
      return i960_out_movq(operands[0], operands[1]);
    case 1:
      return i960_output_ldconst (operands[0], operands[1]);
    case 2:
      return i960_out_ldq(operands[0], operands[1]);
    case 3:
      return i960_out_stq(operands[0], operands[1]);
    }
}"
  [(set_attr "type" "move,reglda,load,store")])

(define_split
  [(set (match_operand:TI 0 "register_operand" "")
        (match_operand:TI 1 "register_operand" ""))]
  "reload_completed && TARGET_J_SERIES &&
   GET_CODE (operands[0]) == REG && REGNO(operands[0]) < 32 &&
   GET_CODE (operands[1]) == REG && REGNO(operands[1]) < 32"

  [(set (subreg:SI (match_dup 0) 0) (subreg:SI (match_dup 1) 0))
   (set (subreg:SI (match_dup 0) 1) (subreg:SI (match_dup 1) 1))
   (set (subreg:SI (match_dup 0) 2) (subreg:SI (match_dup 1) 2))
   (set (subreg:SI (match_dup 0) 3) (subreg:SI (match_dup 1) 3))]
  "")

(define_expand "store_multiple"
  [(set (match_operand:SI 0 "" "")	;;- dest
	(match_operand:SI 1 "" ""))	;;- src
   (use (match_operand:SI 2 "" ""))]	;;- nregs
  ""
  "
{
  if (1) /* suppress unused code messages */
  {
    int regno;
    int count;
    rtx from;
    int i;
    tree mt,rt;

    if (GET_CODE (operands[0]) != MEM
        || GET_CODE (operands[1]) != REG
        || GET_CODE (operands[2]) != CONST_INT)
      FAIL;

    if ((mt = get_rtx_type(operands[0])) == 0)
      mt = get_rtx_type(operands[1]);

    if ((rt = get_rtx_type(operands[1])) == 0)
      rt = get_rtx_type(operands[0]);

    count = INTVAL (operands[2]);
    if (count > 12)
      FAIL;

    regno = REGNO (operands[1]);
    from = memory_address (SImode, XEXP (operands[0], 0));
    while (count >= 4 && ((regno & 3) == 0))
    {
      emit_insn (gen_rtx (SET, VOIDmode,
			  embed_type (gen_rtx (MEM,TImode,from),mt),
			  embed_type (gen_rtx (REG,TImode,regno),rt)));
      count -= 4;
      regno += 4;
      from = memory_address (TImode, plus_constant (from, 16));
    }
    while (count >= 2 && ((regno & 1) == 0))
    {
      emit_insn (gen_rtx (SET, VOIDmode,
			  embed_type (gen_rtx (MEM,DImode,from),mt),
			  embed_type (gen_rtx (REG,DImode,regno),rt)));
      count -= 2;
      regno += 2;
      from = memory_address (DImode, plus_constant (from, 8));
    }
    while (count > 0)
    {
      emit_insn (gen_rtx (SET, VOIDmode,
			  embed_type (gen_rtx (MEM,SImode,from),mt),
			  embed_type (gen_rtx (REG,SImode,regno),rt)));
      count -= 1;
      regno += 1;
      from = memory_address (SImode, plus_constant (from, 4));
    }
    DONE;
  }
}")

;; Floating point move insns

(define_expand "movdf"
  [(set (match_operand:DF 0 "move_operand" "")
	(match_operand:DF 1 "move_operand" ""))]
  ""
  "
{
  if (emit_move_sequence (operands, DFmode))
    DONE;
}")

(define_insn ""
  [(set (match_operand:DF 0 "move_operand" "=tf,f,t,t,m")
	(match_operand:DF 1 "move_operand" "tf,GH,F,m,t"))]
  ""
  "*
{
  switch (which_alternative)
    {
    case 0:
      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))
	return \"movrl	%1,%0\";
      else
        return i960_out_movl(operands[0], operands[1]);
    case 1:
      return \"movrl	%1,%0\";
    case 2:
      return i960_output_ldconst (operands[0], operands[1]);
    case 3:
      return i960_out_ldl(operands[0], operands[1]);
    case 4:
      return i960_out_stl(operands[0], operands[1]);
    }
}"
  [(set_attr "type" "move,move,reglda,load,store")])

(define_expand "movsf"
  [(set (match_operand:SF 0 "move_operand" "")
	(match_operand:SF 1 "move_operand" ""))]
  ""
  "
{
  if (emit_move_sequence (operands, SFmode))
    DONE;
}")

(define_insn ""
  [(set (match_operand:SF 0 "move_operand" "=df,f,d,d,m,  d,uvwxyz,u,v,w,x,y,z")
	(match_operand:SF 1 "move_operand" "df,GH,F,m,dG, uvwxyz,d,u,v,w,x,y,z"))]
  ""
  "*
{
  switch (which_alternative)
    {
    default:
    { extern char* i960_out_cop_move();
      return i960_out_cop_move (operands);
    }

    case 0:
      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))
	return \"movr	%1,%0\";
      else
      {
        if (i960_last_insn_type == I_TYPE_REG &&
            (TARGET_C_SERIES || TARGET_H_SERIES))
        {
          if (GET_CODE (operands[1]) == REG)
            return \"lda	(%1),%0\";
          else
            return \"lda	%1,%0\";
        }
	return \"mov	%1,%0\";
      }
    case 1:
      return \"movr	%1,%0\";
    case 2:
      return i960_output_ldconst (operands[0], operands[1]);
    case 3:
      return \"ld	%1,%0\";
    case 4:
      if (operands[1] == CONST0_RTX (SFmode))
	return \"st	g14,%0\";
      return \"st	%1,%0\";
    }
}"
  [(set_attr "type" "reglda,move,reglda,load,store,move,move,move,move,move,move,move,move")])

(define_expand "movtf"
  [(set (match_operand:TF 0 "move_operand" "")
	(match_operand:TF 1 "move_operand" ""))]
  ""
  "
{
  if (emit_move_sequence (operands, TFmode))
    DONE;
}")

(define_insn ""
  [(set (match_operand:TF 0 "move_operand" "=qf,f,q,q,m")
	(match_operand:TF 1 "move_operand" "qf,GH,F,m,q"))]
  ""
  "*
{
  switch (which_alternative)
    {
    case 0:
      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))
	return \"movre	%1,%0\";
      else
        return i960_out_movq(operands[0], operands[1]);
    case 1:
      return \"movre	%1,%0\";
    case 2:
      return i960_output_ldconst (operands[0], operands[1]);
    case 3:
      return i960_out_ldq(operands[0], operands[1]);
    case 4:
      return i960_out_stq(operands[0], operands[1]);
    }
}"
  [(set_attr "type" "move,move,reglda,load,store")])

;; Mixed-mode moves with sign and zero-extension.

;; Note that the one starting from HImode comes before those for QImode
;; so that a constant operand will match HImode, not QImode.

(define_expand "extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(sign_extend:SI
	 (match_operand:HI 1 "nonimmediate_operand" "")))]
 ""
 "
{
  if (GET_CODE (operand1) == REG
      || (GET_CODE (operand1) == SUBREG
	  && GET_CODE (XEXP (operand1, 0)) == REG))
    {
      rtx temp = gen_reg_rtx (SImode);
      rtx shift_16 = GEN_INT(16);
      int op1_subreg_word = 0;

      if (GET_CODE (operand1) == SUBREG)
	{
	  op1_subreg_word = SUBREG_WORD (operand1);
	  operand1 = SUBREG_REG (operand1);
	}
      operand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);

      emit_insn (gen_ashlsi3 (temp, operand1, shift_16));
      emit_insn (gen_ashrsi3 (operand0, temp, shift_16));
      DONE;
    }
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(sign_extend:SI (match_operand:HI 1 "memory_operand" "m")))]
  ""
  "ldis	%1,%0"
  [(set_attr "type" "load")])

(define_expand "extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
  ""
  "
{
  if (GET_CODE (operand1) == REG
      || (GET_CODE (operand1) == SUBREG
	  && GET_CODE (XEXP (operand1, 0)) == REG))
    {
      rtx temp = gen_reg_rtx (SImode);
      rtx shift_24 = GEN_INT(24);
      int op1_subreg_word = 0;

      if (GET_CODE (operand1) == SUBREG)
	{
	  op1_subreg_word = SUBREG_WORD (operand1);
	  operand1 = SUBREG_REG (operand1);
	}
      operand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word),

      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));
      emit_insn (gen_ashrsi3 (operand0, temp, shift_24));
      DONE;
    }
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(sign_extend:SI (match_operand:QI 1 "memory_operand" "m")))]
  ""
  "ldib	%1,%0"
  [(set_attr "type" "load")])

(define_expand "extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "")
	(sign_extend:HI
	 (match_operand:QI 1 "nonimmediate_operand" "")))]
  ""
  "
{
  if (GET_CODE (operand1) == REG
      || (GET_CODE (operand1) == SUBREG
	  && GET_CODE (XEXP (operand1, 0)) == REG))
    {
      rtx temp = gen_reg_rtx (SImode);
      rtx shift_24 = GEN_INT(24);
      int op0_subreg_word = 0;
      int op1_subreg_word = 0;

      if (GET_CODE (operand1) == SUBREG)
	{
	  op1_subreg_word = SUBREG_WORD (operand1);
	  operand1 = SUBREG_REG (operand1);
	}
      operand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);

      if (GET_CODE (operand0) == SUBREG)
	{
	  op0_subreg_word = SUBREG_WORD (operand0);
	  operand0 = SUBREG_REG (operand0);
	}
      if (GET_MODE (operand0) != SImode)
	operand0 = gen_rtx (SUBREG, SImode, operand0, op0_subreg_word);

      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));
      emit_insn (gen_ashrsi3 (operand0, temp, shift_24));
      DONE;
    }
}")

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=d")
	(sign_extend:HI (match_operand:QI 1 "memory_operand" "m")))]
  ""
  "ldib	%1,%0"
  [(set_attr "type" "load")])

(define_expand "zero_extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(zero_extend:SI
	 (match_operand:HI 1 "nonimmediate_operand" "")))]
 ""
 "
{
  if (GET_CODE (operand1) == REG
      || (GET_CODE (operand1) == SUBREG
	  && GET_CODE (XEXP (operand1, 0)) == REG))
    {
      rtx mask_16 = GEN_INT(0xFFFF);
      int op1_subreg_word = 0;

      if (GET_CODE (operand1) == SUBREG)
	{
	  op1_subreg_word = SUBREG_WORD (operand1);
	  operand1 = SUBREG_REG (operand1);
	}
      operand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);

      emit_insn (gen_andsi3 (operand0, operand1, mask_16));
      DONE;
    }
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(zero_extend:SI (match_operand:HI 1 "memory_operand" "m")))]
  ""
  "ldos	%1,%0"
  [(set_attr "type" "load")])

(define_expand "zero_extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
  ""
  "
{
  if (GET_CODE (operand1) == REG
      || (GET_CODE (operand1) == SUBREG
	  && GET_CODE (XEXP (operand1, 0)) == REG))
    {
      rtx mask_8 = GEN_INT(0xFF);
      int op1_subreg_word = 0;

      if (GET_CODE (operand1) == SUBREG)
	{
	  op1_subreg_word = SUBREG_WORD (operand1);
	  operand1 = SUBREG_REG (operand1);
	}
      operand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);

      emit_insn (gen_andsi3 (operand0, operand1, mask_8));
      DONE;
    }
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(zero_extend:SI (match_operand:QI 1 "memory_operand" "m")))]
  ""
  "ldob	%1,%0"
  [(set_attr "type" "load")])

(define_expand "zero_extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "")
	(zero_extend:HI
	 (match_operand:QI 1 "nonimmediate_operand" "")))]
  ""
  "
{
  if (GET_CODE (operand1) == REG
      || (GET_CODE (operand1) == SUBREG
	  && GET_CODE (XEXP (operand1, 0)) == REG))
    {
      rtx temp = gen_reg_rtx (SImode);
      rtx shift_24 = GEN_INT(24);
      int op0_subreg_word = 0;
      int op1_subreg_word = 0;

      if (GET_CODE (operand1) == SUBREG)
	{
	  op1_subreg_word = SUBREG_WORD (operand1);
	  operand1 = SUBREG_REG (operand1);
	}
      operand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);

      if (GET_CODE (operand0) == SUBREG)
	{
	  op0_subreg_word = SUBREG_WORD (operand0);
	  operand0 = SUBREG_REG (operand0);
	}
      if (GET_MODE (operand0) != SImode)
	operand0 = gen_rtx (SUBREG, SImode, operand0, op0_subreg_word);

      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));
      emit_insn (gen_lshrsi3 (operand0, temp, shift_24));
      DONE;
    }
}")

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=d")
	(zero_extend:HI (match_operand:QI 1 "memory_operand" "m")))]
  ""
  "ldob	%1,%0"
  [(set_attr "type" "load")])

;; SF/DF to DF/TF conversions
(define_insn "extendsfdf2"
  [(set (match_operand:DF 0 "register_operand" "=f,t")
	(float_extend:DF (match_operand:SF 1 "fp_arith_operand" "tGH,fGH")))]
  "TARGET_NUMERICS"
  "@
  movr	%1,%0
  movrl	%1,%0"
  [(set_attr "type" "fpmove")])

(define_insn "extendsftf2"
  [(set (match_operand:TF 0 "register_operand" "=f,q")
	(float_extend:TF (match_operand:SF 1 "fp_arith_operand" "dGH,fGH")))]
  "TARGET_NUMERICS"
  "@
  movr	%1,%0
  movre	%1,%0"
  [(set_attr "type" "fpmove")])

(define_insn "extenddftf2"
  [(set (match_operand:TF 0 "register_operand" "=f,q")
	(float_extend:TF (match_operand:DF 1 "fp_arith_operand" "tGH,fGH")))]
  "TARGET_NUMERICS"
  "@
  movrl	%1,%0
  movre	%1,%0"
  [(set_attr "type" "fpmove")])

;; DF/TF to SF/DF conversions

(define_insn "truncdfsf2"
  [(set (match_operand:SF 0 "register_operand" "=d")
	(float_truncate:SF (match_operand:DF 1 "fp_arith_operand" "fGH")))]
  "TARGET_NUMERICS"
  "movr	%1,%0"
  [(set_attr "type" "fpmove")])

(define_insn "trunctfdf2"
  [(set (match_operand:DF 0 "register_operand" "=t")
	(float_truncate:DF (match_operand:TF 1 "fp_arith_operand" "fGH")))]
  "TARGET_NUMERICS"
  "movrl	%1,%0"
  [(set_attr "type" "fpmove")])

(define_insn "trunctfsf2"
  [(set (match_operand:SF 0 "register_operand" "=d")
	(float_truncate:SF (match_operand:TF 1 "fp_arith_operand" "fGH")))]
  "TARGET_NUMERICS"
  "movr	%1,%0"
  [(set_attr "type" "fpmove")])

;; Conversion between fixed point and floating point.

(define_insn "floatsidf2"
  [(set (match_operand:DF 0 "register_operand" "=f")
	(float:DF (match_operand:SI 1 "nonmemory_operand" "d")))]
  "TARGET_NUMERICS"
  "cvtir	%1,%0"
  [(set_attr "type" "fpcvt")])

(define_insn "floatsitf2"
  [(set (match_operand:TF 0 "register_operand" "=f")
	(float:TF (match_operand:SI 1 "nonmemory_operand" "d")))]
  "TARGET_NUMERICS"
  "cvtir	%1,%0"
  [(set_attr "type" "fpcvt")])

(define_insn "floatsisf2"
  [(set (match_operand:SF 0 "register_operand" "=df")
	(float:SF (match_operand:SI 1 "nonmemory_operand" "d")))]
  "TARGET_NUMERICS"
  "cvtir	%1,%0"
  [(set_attr "type" "fpcvt")])

;; Convert a float to an actual integer.
;; Truncation is performed as part of the conversion.
;; The i960 requires conversion from DFmode to DImode to make
;; unsigned conversions work properly.

(define_expand "fix_truncsfsi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(fix:SI (fix:SF (match_operand:SF 1 "fp_arith_operand" ""))))]
  ""
  "
{
  if (1) /* suppress unused code messages */
  {
    if (TARGET_NUMERICS)
      /* Matched below in nameless pattern */
      emit_insn (gen_rtx (SET, VOIDmode, operands[0],
  		        gen_rtx (FIX, SImode,
  			         gen_rtx (FIX, SFmode, operands[1]))));
    else
      i960_emit_libcall(FIX,CODE_FOR_fix_truncsfsi2,operands);

    DONE;
  }
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(fix:SI (fix:SF (match_operand:SF 1 "fp_arith_operand" "dfGH"))))]
  "TARGET_NUMERICS"
  "cvtzri	%1,%0"
  [(set_attr "type" "fpcvt")])


(define_insn "fix_truncdfsi2"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(fix:SI (fix:DF (match_operand:DF 1 "fp_arith_operand" "fGH"))))]
  "TARGET_NUMERICS"
  "cvtzri	%1,%0"
  [(set_attr "type" "fpcvt")])

(define_insn "fix_trunctfsi2"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(fix:SI (fix:TF (match_operand:TF 1 "fp_arith_operand" "fGH"))))]
  "TARGET_NUMERICS"
  "cvtzri	%1,%0"
  [(set_attr "type" "fpcvt")])

(define_expand "fixuns_truncdfsi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(unsigned_fix:SI (fix:DF (match_operand:DF 1 "fp_arith_operand" ""))))]
  "TARGET_NUMERICS"
  "
{
  if (1) /* suppress unused code messages */
  {
    rtx temp = gen_reg_rtx (DImode);
    emit_insn (gen_rtx (SET, VOIDmode, temp,
		        gen_rtx (UNSIGNED_FIX, DImode,
			         gen_rtx (FIX, DFmode, operands[1]))));
    emit_insn (gen_rtx (SET, VOIDmode, operands[0],
		        gen_rtx (SUBREG, SImode, temp, 0)));
    DONE;
  }
}")

(define_expand "fixuns_truncsfsi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(unsigned_fix:SI (fix:SF (match_operand:SF 1 "fp_arith_operand" ""))))]
  ""
  "
{
  if (1) /* suppress unused code messages */
  {
    if (TARGET_NUMERICS)
    {
      rtx temp = gen_reg_rtx (DImode);
      emit_insn (gen_rtx (SET, VOIDmode, temp,
  		        gen_rtx (UNSIGNED_FIX, DImode,
  			         gen_rtx (FIX, SFmode, operands[1]))));
      emit_insn (gen_rtx (SET, VOIDmode, operands[0],
  		        gen_rtx (SUBREG, SImode, temp, 0)));
    }
    else
      i960_emit_libcall(UNSIGNED_FIX,CODE_FOR_fixuns_truncsfsi2,operands);

    DONE;
  }
}")

(define_insn "fixuns_truncdfdi2"
  [(set (match_operand:DI 0 "register_operand" "=t")
	(unsigned_fix:DI (fix:DF (match_operand:DF 1 "fp_arith_operand" "fGH"))))]
  "TARGET_NUMERICS"
  "cvtzril	%1,%0"
  [(set_attr "type" "fpcvt")])

(define_insn "fixuns_truncsfdi2"
  [(set (match_operand:DI 0 "register_operand" "=t")
	(unsigned_fix:DI (fix:SF (match_operand:SF 1 "fp_arith_operand" "fGH"))))]
  "TARGET_NUMERICS"
  "cvtzril	%1,%0"
  [(set_attr "type" "fpcvt")])

(define_insn "fixuns_trunctfsi2"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(unsigned_fix:SI (fix:TF (match_operand:TF 1 "register_operand" "f"))))]
  "TARGET_NUMERICS"
  "cvtzri	%1,%0"
  [(set_attr "type" "fpcvt")])

;; Arithmetic instructions.

(define_insn "subsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(minus:SI (match_operand:SI 1 "nonmemory_operand" "dI")
		  (match_operand:SI 2 "nonmemory_operand" "dI")))]
  ""
  "subo	%2,%1,%0")

;; Try to generate an lda instruction when it would be faster than an
;; add instruction.
;; Some assemblers apparently won't accept two addresses added together.

(define_insn "addsi3"
  [(set (match_operand:SI 0 "register_operand" "=d,d,d,d")
        (plus:SI (match_operand:SI 1 "nonmemory_operand" "%d,d,d,dn")
                 (match_operand:SI 2 "nonmemory_operand" "d,I,K,i")))]
  ""
  "*
{
  if (i960_bypass(insn,operands[1],operands[2],0))
  {
    rtx t;
    t = operands[1];
    operands[1] = operands[2];
    operands[2] = t;
  }

  if (CONSTANT_P(operands[2]) && CONSTANT_P(operands[1]))
    return \"lda	%1+%2,%0\";

  if (CONSTANT_P(operands[2]))
  {
    if (INTVAL(operands[2]) < 0 && INTVAL(operands[2]) > -32)
      return \"subo	%n2,%1,%0\";

    if (GET_CODE(operands[2]) == CONST_INT &&
        GET_CODE(operands[1]) == REG &&
        (i960_last_insn_type != I_TYPE_REG ||
         !(TARGET_C_SERIES || TARGET_H_SERIES)) &&
        INTVAL(operands[2]) >= 0 && INTVAL(operands[2]) < 32)
      return \"addo	%1,%2,%0\";
    return \"lda	%2(%1),%0\";
  }

  if (CONSTANT_P(operands[1]))
  {
    if (INTVAL(operands[1]) < 0 && INTVAL(operands[1]) > -32)
      return \"subo	%n1,%2,%0\";

    if (GET_CODE(operands[1]) == CONST_INT &&
        GET_CODE(operands[2]) == REG &&
        (i960_last_insn_type != I_TYPE_REG ||
         !(TARGET_C_SERIES || TARGET_H_SERIES)) &&
        INTVAL(operands[1]) >= 0 && INTVAL(operands[1]) < 32)
      return \"addo	%2,%1,%0\";
    return \"lda	%1(%2),%0\";
  }

  return \"addo	%1,%2,%0\";
}"
  [(set_attr "type" "arith,reglda,arith,address")])

(define_insn "mulsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(mult:SI (match_operand:SI 1 "nonmemory_operand" "%dI")
		 (match_operand:SI 2 "nonmemory_operand" "dI")))]
  ""
  "*
{
  if (TARGET_CPMUL)
    return \"cpmulo	%1,%2,%0\";

  if (i960_bypass (insn, operands[1], operands[2], 0))
    return \"mulo	%2,%1,%0\";
  return \"mulo	%1,%2,%0\";
}"
  [(set_attr "type" "mult")])

;; These goe after the move/add/sub/mul instructions  
;; because those instructions are better when they apply.

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (plus:SI (mult:SI (match_operand:SI 1 "nonmemory_operand" "d")
                          (match_operand:SI 2 "immediate_operand" ""))
                 (match_operand:SI 3 "immediate_operand" "i")))]
  "SCALE_TERM_P(operands[2])"
  "*
  {
    operands[0] = SET_DEST(PATTERN(insn));
    operands[1] = SET_SRC(PATTERN(insn));
    return i960_best_lda_sequence(operands);
  }"
  [(set_attr "type" "address")])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (plus:SI (mult:SI (match_operand:SI 1 "nonmemory_operand" "d")
                          (match_operand:SI 2 "immediate_operand" ""))
                 (match_operand:SI 3 "register_operand" "d")))]
  "SCALE_TERM_P(operands[2]) &&
   (flag_space_opt ||
    TARGET_K_SERIES || TARGET_C_SERIES)"
  "*
  {
    operands[0] = SET_DEST(PATTERN(insn));
    operands[1] = SET_SRC(PATTERN(insn));
    return i960_best_lda_sequence(operands);
  }"
  [(set_attr "type" "address")])

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (mult:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))
   (set (match_operand:SI 4 "register_operand" "")
        (plus:SI (match_dup 0)
                 (match_operand:SI 3 "register_operand" "")))]
  "SCALE_TERM_P(operands[2]) && dead_or_set_p(insn, operands[0]) &&
   i960_last_insn_type != I_TYPE_REG"
  "*
{
  operands[0] = operands[4];
  operands[1] = gen_rtx(PLUS, SImode,
                        gen_rtx(MULT, SImode, operands[1], operands[2]),
                        operands[3]);
  return i960_best_lda_sequence(operands);
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (plus:SI (plus:SI (match_operand:SI 1 "nonmemory_operand" "d")
                          (match_operand:SI 2 "nonmemory_operand" "d"))
                 (match_operand:SI 3 "immediate_operand" "i")))]
  "(flag_space_opt ||
    TARGET_K_SERIES || TARGET_C_SERIES)"
  "*
  {
    operands[0] = SET_DEST(PATTERN(insn));
    operands[1] = SET_SRC(PATTERN(insn));
    return i960_best_lda_sequence(operands);
  }"
  [(set_attr "type" "address")])

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "register_operand" "")))
   (set (match_operand:SI 4 "register_operand" "")
        (plus:SI (match_dup 0)
                 (match_operand:SI 3 "immediate_operand" "")))]
  "dead_or_set_p(insn, operands[0])"
  "*
{
  operands[0] = operands[4];
  operands[1] = gen_rtx(PLUS, SImode,
                        gen_rtx(PLUS, SImode, operands[1], operands[2]),
                        operands[3]);
  return i960_best_lda_sequence(operands);
}")

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_operand:SI 1 "register_operand" "")
                 (match_operand:SI 2 "immediate_operand" "")))
   (set (match_operand:SI 4 "register_operand" "")
        (plus:SI (match_dup 0)
                 (match_operand:SI 3 "register_operand" "")))]
  "dead_or_set_p(insn, operands[0]) && i960_last_insn_type != I_TYPE_REG"
  "*
{
  operands[0] = operands[4];
  operands[1] = gen_rtx(PLUS, SImode, 
                        gen_rtx(PLUS, SImode, operands[1], operands[3]),
                        operands[2]);
  return i960_best_lda_sequence(operands);
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (plus:SI (plus:SI (mult:SI (match_operand:SI 1 "nonmemory_operand" "d")
                                   (match_operand:SI 2 "immediate_operand" ""))
                          (match_operand:SI 3 "nonmemory_operand" "d"))
                 (match_operand:SI 4 "immediate_operand" "i")))]
  "SCALE_TERM_P(operands[2]) &&
   (flag_space_opt ||
    TARGET_K_SERIES ||
    ((TARGET_C_SERIES) &&
      !(INTVAL(operands[2]) == 1 &&
        GET_CODE(operands[4]) == CONST_INT &&
        INTVAL(operands[4]) >= -31 && INTVAL(operands[4]) <= 31)))"
  "*
  {
    operands[0] = SET_DEST(PATTERN(insn));
    operands[1] = SET_SRC(PATTERN(insn));
    return i960_best_lda_sequence(operands);
  }"
  [(set_attr "type" "address")])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (div:SI (match_operand:SI 1 "nonmemory_operand" "dI")
                (match_operand:SI 2 "power2_operand" "n")))]
  ""
  "*
  {
    operands[2] = GEN_INT(bitpos (INTVAL (operands[2])));
    return \"shrdi	%2,%1,%0\";
  }")

(define_expand "divsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
        (div:SI (match_operand:SI 1 "nonmemory_operand" "dI")
                (match_operand:SI 2 "nonmemory_operand" "dI")))]
  ""
  ""
)

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&d")
        (div:SI (match_operand:SI 1 "nonmemory_operand" "dI")
                (match_operand:SI 2 "nonmemory_operand" "dI")))]
  "TARGET_J_SERIES"
  "divi	%2,%1,%0"
  [(set_attr "type" "div")])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
        (div:SI (match_operand:SI 1 "nonmemory_operand" "dI")
                (match_operand:SI 2 "nonmemory_operand" "dI")))]
  "!TARGET_J_SERIES"
  "divi	%2,%1,%0"
  [(set_attr "type" "div")])

(define_insn "udivsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
        (udiv:SI (match_operand:SI 1 "nonmemory_operand" "dI")
		 (match_operand:SI 2 "nonmemory_operand" "dI")))]
  ""
  "divo	%2,%1,%0"
  [(set_attr "type" "div")])

;; We must use `remi' not `modi' here, to ensure that `%' has the effects
;; specified by the ANSI C standard.

(define_insn "modsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
        (mod:SI (match_operand:SI 1 "nonmemory_operand" "dI")
                (match_operand:SI 2 "nonmemory_operand" "dI")))]
  ""
  "remi	%2,%1,%0"
  [(set_attr "type" "div")])

(define_insn "umodsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
        (umod:SI (match_operand:SI 1 "nonmemory_operand" "dI")
		 (match_operand:SI 2 "nonmemory_operand" "dI")))]
  ""
  "remo	%2,%1,%0"
  [(set_attr "type" "div")])

;;- and instructions (with compliment also)			   
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(and:SI (match_operand:SI 1 "nonmemory_operand" "dI")
		(match_operand:SI 2 "inv_power2_operand" "n")))]
  ""
  "*
{
  operands[2] = GEN_INT(bitpos(~INTVAL(operands[2])));
  return      \"clrbit	%2,%1,%0\";
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(and:SI (rotate:SI (match_operand:SI 1 "immediate_operand" "i")
                           (match_operand:SI 2 "nonmemory_operand" "dI"))
		(match_operand:SI 3 "nonmemory_operand" "dI")))]
  "(GET_CODE(operands[1]) == CONST_INT && INTVAL(operands[1]) == -2)"
  "clrbit	%2,%3,%0"
)

(define_insn "andsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(and:SI (match_operand:SI 1 "nonmemory_operand" "%dI")
		(match_operand:SI 2 "nonmemory_operand" "dIL")))]
  ""
  "*
{
  if (GET_CODE(operands[2]) == CONST_INT &&
      ((unsigned)INTVAL(operands[2])) > 31)
  {
    operands[2] = GEN_INT(~INTVAL(operands[2]));
    return \"notand	%1,%2,%0\";
  }

  if (i960_bypass(insn,operands[1],operands[2],0))
    return \"and	%2,%1,%0\";
  return \"and	%1,%2,%0\";
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(and:SI (match_operand:SI 1 "nonmemory_operand" "dI")
		(not:SI (match_operand:SI 2 "nonmemory_operand" "dI"))))]
  ""
  "*
{
  if (i960_bypass(insn,operands[1],operands[2],0))
    return \"andnot	%2,%1,%0\";
  return \"notand	%1,%2,%0\";
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(and:SI (not:SI (match_operand:SI 1 "nonmemory_operand" "dI"))
		(match_operand:SI 2 "nonmemory_operand" "dI")))]
  ""
  "*
{
  if (i960_bypass(insn,operands[1],operands[2],0))
    return \"notand	%2,%1,%0\";
  return \"andnot	%1,%2,%0\";
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(ior:SI (not:SI (match_operand:SI 1 "nonmemory_operand" "%dI"))
		(not:SI (match_operand:SI 2 "nonmemory_operand" "dI"))))]
  ""
  "*
{
  if (i960_bypass(insn,operands[1],operands[2],0))
    return \"nand       %2,%1,%0\";
  return \"nand	%1,%2,%0\";
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(not:SI (and:SI (match_operand:SI 1 "nonmemory_operand" "%dI")
			(match_operand:SI 2 "nonmemory_operand" "dI"))))]
  ""
  "*
{
  if (i960_bypass(insn,operands[1],operands[2],0))
    return \"nand	%2,%1,%0\";
  return \"nand     %1,%2,%0\";
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(ior:SI (match_operand:SI 1 "nonmemory_operand" "dI")
		(match_operand:SI 2 "power2_operand" "n")))]
  ""
  "*
{
  operands[2] = GEN_INT(bitpos(INTVAL(operands[2])));
  return	\"setbit	%2,%1,%0\";
}")

(define_insn "iorsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(ior:SI (match_operand:SI 1 "nonmemory_operand" "%dI")
		(match_operand:SI 2 "nonmemory_operand" "dIL")))]
  ""
  "*
{
  if (GET_CODE(operands[2]) == CONST_INT &&
      ((unsigned)INTVAL(operands[2])) > 31)
  {
    operands[2] = GEN_INT(~INTVAL(operands[2]));
    return \"notor	%1,%2,%0\";
  }

  if (i960_bypass(insn,operands[1],operands[2],0))
    return \"or	%2,%1,%0\";
  return \"or	%1,%2,%0\";
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(ior:SI (match_operand:SI 1 "nonmemory_operand" "dI")
		(not:SI (match_operand:SI 2 "nonmemory_operand" "dI"))))]
  ""
  "*
{
  if (i960_bypass(insn,operands[1],operands[2],0))
    return \"ornot	%2,%1,%0\";
  return \"notor	%1,%2,%0\";
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(ior:SI (not:SI (match_operand:SI 1 "nonmemory_operand" "dI"))
		(match_operand:SI 2 "nonmemory_operand" "dI")))]
  ""
  "*
{
  if (i960_bypass(insn,operands[1],operands[2],0))
    return \"notor	%2,%1,%0\";
  return \"ornot    %1,%2,%0\";
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(and:SI (not:SI (match_operand:SI 1 "nonmemory_operand" "%dI"))
		(not:SI (match_operand:SI 2 "nonmemory_operand" "dI"))))]
  ""
  "*
{
  if (i960_bypass(insn,operands[1],operands[2],0))
    return \"nor	%2,%1,%0\";
  return \"nor	%1,%2,%0\";
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(not:SI (ior:SI (match_operand:SI 1 "nonmemory_operand" "%dI")
			(match_operand:SI 2 "nonmemory_operand" "dI"))))]
  ""
  "*
{
  if (i960_bypass(insn,operands[1],operands[2],0))
    return \"nor	%2,%1,%0\";
  return \"nor	%1,%2,%0\";
}")

(define_insn "xorsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(xor:SI (match_operand:SI 1 "nonmemory_operand" "%dI")
		(match_operand:SI 2 "nonmemory_operand" "dI")))]
  ""
  "*
{
  if (i960_bypass(insn,operands[1],operands[2],0))
    return \"xor	%2,%1,%0\";
  return \"xor	%1,%2,%0\";
}")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(not:SI (xor:SI (match_operand:SI 1 "nonmemory_operand" "%dI")
			(match_operand:SI 2 "nonmemory_operand" "dI"))))]
  ""
  "*
{
  if (i960_bypass(insn,operands[1],operands[2],0))
    return \"xnor	%2,%1,%0\";
  return \"xnor	%1,%2,%0\";
}")

(define_insn "negsi2"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(neg:SI (match_operand:SI 1 "nonmemory_operand" "dI")))]
  ""
  "subo	%1,0,%0"
  [])

(define_insn "one_cmplsi2"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(not:SI (match_operand:SI 1 "nonmemory_operand" "dI")))]
  ""
  "not	%1,%0"
  [])

;; Floating point arithmetic instructions.

(define_insn "adddf3"
  [(set (match_operand:DF 0 "register_operand" "=t")
	(plus:DF (match_operand:DF 1 "fp_arith_operand" "%tfGH")
		 (match_operand:DF 2 "fp_arith_operand" "tfGH")))]
  "TARGET_NUMERICS"
  "addrl	%1,%2,%0"
  [(set_attr "type" "fpadd")])

(define_insn "addsf3"
  [(set (match_operand:SF 0 "register_operand" "=d")
	(plus:SF (match_operand:SF 1 "fp_arith_operand" "%dfGH")
		 (match_operand:SF 2 "fp_arith_operand" "dfGH")))]
  "TARGET_NUMERICS"
  "addr	%1,%2,%0"
  [(set_attr "type" "fpadd")])

(define_insn "addtf3"
  [(set (match_operand:TF 0 "register_operand" "=f")
	(plus:TF (match_operand:TF 1 "fp_arith_operand" "%fGH")
		 (match_operand:TF 2 "fp_arith_operand" "fGH")))]
  "TARGET_NUMERICS"
  "addr	%1,%2,%0"
  [(set_attr "type" "fpadd")])


(define_insn "subdf3"
  [(set (match_operand:DF 0 "register_operand" "=t")
	(minus:DF (match_operand:DF 1 "fp_arith_operand" "tfGH")
		  (match_operand:DF 2 "fp_arith_operand" "tfGH")))]
  "TARGET_NUMERICS"
  "subrl	%2,%1,%0"
  [(set_attr "type" "fpadd")])

(define_insn "subsf3"
  [(set (match_operand:SF 0 "register_operand" "=d")
	(minus:SF (match_operand:SF 1 "fp_arith_operand" "dfGH")
		  (match_operand:SF 2 "fp_arith_operand" "dfGH")))]
  "TARGET_NUMERICS"
  "subr	%2,%1,%0"
  [(set_attr "type" "fpadd")])

(define_insn "subtf3"
  [(set (match_operand:TF 0 "register_operand" "=f")
	(minus:TF (match_operand:TF 1 "fp_arith_operand" "fGH")
		  (match_operand:TF 2 "fp_arith_operand" "fGH")))]
  "TARGET_NUMERICS"
  "subr	%2,%1,%0"
  [(set_attr "type" "fpadd")])

(define_insn "muldf3"
  [(set (match_operand:DF 0 "register_operand" "=t")
	(mult:DF (match_operand:DF 1 "fp_arith_operand" "tfGH")
		 (match_operand:DF 2 "fp_arith_operand" "tfGH")))]
  "TARGET_NUMERICS"
  "mulrl	%1,%2,%0"
  [(set_attr "type" "fpmul")])

(define_insn "mulsf3"
  [(set (match_operand:SF 0 "register_operand" "=d")
	(mult:SF (match_operand:SF 1 "fp_arith_operand" "dfGH")
		 (match_operand:SF 2 "fp_arith_operand" "dfGH")))]
  "TARGET_NUMERICS"
  "mulr	%1,%2,%0"
  [(set_attr "type" "fpmul")])

(define_insn "multf3"
  [(set (match_operand:TF 0 "register_operand" "=f")
	(mult:TF (match_operand:TF 1 "fp_arith_operand" "fGH")
		 (match_operand:TF 2 "fp_arith_operand" "fGH")))]
  "TARGET_NUMERICS"
  "mulr	%1,%2,%0"
  [(set_attr "type" "fpmul")])


(define_insn "divdf3"
  [(set (match_operand:DF 0 "register_operand" "=t")
	(div:DF (match_operand:DF 1 "fp_arith_operand" "tfGH")
		(match_operand:DF 2 "fp_arith_operand" "tfGH")))]
  "TARGET_NUMERICS"
  "divrl	%2,%1,%0"
  [(set_attr "type" "fpdiv")])

(define_insn "divsf3"
  [(set (match_operand:SF 0 "register_operand" "=d")
	(div:SF (match_operand:SF 1 "fp_arith_operand" "dfGH")
		(match_operand:SF 2 "fp_arith_operand" "dfGH")))]
  "TARGET_NUMERICS"
  "divr	%2,%1,%0"
  [(set_attr "type" "fpdiv")])

(define_insn "divtf3"
  [(set (match_operand:TF 0 "register_operand" "=f")
	(div:TF (match_operand:TF 1 "fp_arith_operand" "fGH")
		(match_operand:TF 2 "fp_arith_operand" "fGH")))]
  "TARGET_NUMERICS"
  "divr	%2,%1,%0"
  [(set_attr "type" "fpdiv")])

(define_insn "negdf2"
  [(set (match_operand:DF 0 "register_operand" "=t")
	(neg:DF (match_operand:DF 1 "register_operand" "t")))]
  ""
  "*
{
  if (REGNO (operands[0]) == REGNO (operands[1]))
    return \"notbit	31,%D1,%D0\";
  return \"mov	%1,%0\;notbit	31,%D1,%D0\";
}"
  [(set_attr "type" "multi")])

(define_insn "negtf2"
  [(set (match_operand:TF 0 "register_operand" "=q")
	(neg:TF (match_operand:TF 1 "register_operand" "q")))]
  ""
  "*
{
  if (REGNO (operands[0]) == REGNO (operands[1]))
    return \"notbit	15,%T1,%T0\";
  return \"movl	%1,%0\;notbit	15,%T1,%T0\";
}"
  [(set_attr "type" "multi")])


(define_insn "negsf2"
  [(set (match_operand:SF 0 "register_operand" "=d")
	(neg:SF (match_operand:SF 1 "register_operand" "d")))]
  ""
  "notbit	31,%1,%0"
  [(set_attr "type" "multi")])

;;; The abs patterns also work even if the target machine doesn't have
;;; floating point, because in that case dstreg and srcreg will always be
;;; less than 32.

(define_insn "absdf2"
  [(set (match_operand:DF 0 "register_operand" "=tf")
	(abs:DF (match_operand:DF 1 "register_operand" "tf")))]
  ""
  "*
{
  int dstreg = REGNO (operands[0]);
  int srcreg = REGNO (operands[1]);

  if (dstreg < 32)
    {
      if (srcreg < 32)
	{
	  if (dstreg != srcreg)
	    output_asm_insn (\"mov	%1,%0\", operands);
	  return \"clrbit	31,%D1,%D0\";
	}
      /* Src is an fp reg.  */
      return \"movrl	%1,%0\;clrbit	31,%D0,%D0\";
    }
  if (srcreg >= 32)
    return \"cpysre	%1,0f0.0,%0\";
  return \"movrl	%1,%0\;cpysre	%0,0f0.0,%0\";
}"
  [(set_attr "type" "multi")])

(define_insn "abstf2"
  [(set (match_operand:TF 0 "register_operand" "=qf")
	(abs:TF (match_operand:TF 1 "register_operand" "qf")))]
  ""
  "*
{
  int dstreg = REGNO (operands[0]);
  int srcreg = REGNO (operands[1]);

  if (dstreg < 32)
    {
      if (srcreg < 32)
	{
	  if (dstreg != srcreg)
	    output_asm_insn (\"mov	%1,%0\", operands);
	  return \"clrbit	15,%T1,%T0\";
	}
      /* Src is an fp reg.  */
      return \"movrl	%1,%0\;clrbit	15,%T0,%T0\";
    }
  if (srcreg >= 32)
    return \"cpysre	%1,0f0.0,%0\";
  return \"movrl	%1,%0\;cpysre	%0,0f0.0,%0\";
}"
  [(set_attr "type" "multi")])

(define_insn "abssf2"
  [(set (match_operand:SF 0 "register_operand" "=df")
	(abs:SF (match_operand:SF 1 "register_operand" "df")))]
  ""
  "*
{
  int dstreg = REGNO (operands[0]);
  int srcreg = REGNO (operands[1]);

  if (dstreg < 32 && srcreg < 32)
    return \"clrbit	31,%1,%0\";

  if (dstreg >= 32 && srcreg >= 32)
    return \"cpysre	%1,0f0.0,%0\";

  if (dstreg < 32)
    return \"movr	%1,%0\;clrbit	31,%0,%0\";

  return \"movr	%1,%0\;cpysre	%0,0f0.0,%0\";
}"
  [(set_attr "type" "multi")])

;; Arithmetic shift instructions.

(define_insn "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(ashift:SI (match_operand:SI 1 "nonmemory_operand" "dI")
		   (match_operand:SI 2 "nonmemory_operand" "dI")))]
  ""
  "*
{
  if (!flag_space_opt &&
      (TARGET_C_SERIES || TARGET_H_SERIES) &&
      i960_last_insn_type == I_TYPE_REG &&
      register_operand (operands[1],VOIDmode) &&
      GET_CODE(operands[2]) == CONST_INT &&
      INTVAL(operands[2]) >= 0 && INTVAL(operands[2]) <= 4)
  {
    static int scale_val[5] = {1,2,4,8,16};
    static char buf[20];
    sprintf (buf, \"lda	[%%1*%d],%%0\", scale_val[INTVAL(operands[2])]);
    return buf;
  }
  else
    return \"shlo	%2,%1,%0\";
}"
  [(set_attr "type" "reglda")])

(define_insn "ashrsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(ashiftrt:SI (match_operand:SI 1 "nonmemory_operand" "dI")
		     (match_operand:SI 2 "nonmemory_operand" "dI")))]
  ""
  "shri	%2,%1,%0"
  [(set_attr "type" "arith")])

(define_insn "lshrsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(lshiftrt:SI (match_operand:SI 1 "nonmemory_operand" "dI")
		   (match_operand:SI 2 "nonmemory_operand" "dI")))]
  ""
  "shro	%2,%1,%0"
  [(set_attr "type" "arith")])

;; Unconditional and other jump instructions.

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "b	%l0"
  [(set_attr "type" "branch")])

(define_insn "indirect_jump"
  [(set (pc) (match_operand:SI 0 "register_operand" "d"))]
  ""
  "bx	(%0)"
  [(set_attr "type" "branch")])

(define_insn "tablejump"
  [(set (pc) (match_operand:SI 0 "register_operand" "d"))
   (use (label_ref (match_operand 1 "" "")))]
  ""
  "bx	(%0)"
  [(set_attr "type" "branch")])

;;- jump to subroutine

(define_expand "call"
  [(match_operand:SI 0 "memory_operand" "")
   (match_operand:SI 1 "immediate_operand" "")
   (match_operand 2 "general_operand" "")]
  ""
  "
{
  if (1) /* suppress unused code messages */
  {
    i960_expand_call (operand0, operand1, operand2, NULL_RTX);
    DONE;
  }
}")

(define_insn ""
  [(call (match_operand:SI 0 "memory_operand" "m")
	 (match_operand:SI 1 "immediate_operand" "i"))
   (clobber (match_operand:TI 2 "register_operand" "q"))]
  ""
  "* return i960_output_call_insn (operands[0], operands[1], insn);"
  [(set_attr "type" "call")])

(define_expand "call_value"
  [(match_operand 0 "register_operand" "")
   (match_operand:SI 1 "memory_operand" "")
   (match_operand:SI 2 "immediate_operand" "")
   (match_operand 3 "general_operand" "")]
  ""
  "
{
  if (1) /* suppress unused code messages */
  {
    i960_expand_call (operand1, operand2, operand3, operand0);
    DONE;
  }
}")

(define_insn ""
  [(set (match_operand 0 "register_operand" "=dtqf")
	(call (match_operand:SI 1 "memory_operand" "m")
	      (match_operand:SI 2 "immediate_operand" "i")))
   (clobber (match_operand:TI 3 "register_operand" "q"))]
  ""
  "* return i960_output_call_insn (operands[1], operands[2], insn);"
  [(set_attr "type" "call")])

(define_expand "return"
  [(return)]
  ""
  "
{
  if (1) /* suppress unused code messages */
  {
    i960_expand_return ();
    DONE;
  }
}")

(define_insn ""
  [(return)]
  ""
  "* return i960_output_ret_insn (insn);"
  [(set_attr "type" "branch")])

(define_insn "nop"
  [(const_int 0)]
  ""
  "")

;; Various peephole optimizations for multiple-word moves, loads, and stores.
;; Multiple register moves.

;; Matched 5/28/91
(define_peephole
  [(set (match_operand:SI 0 "register_operand" "=d")
	(match_operand:SI 1 "register_operand" "d"))
   (set (match_operand:SI 2 "register_operand" "=d")
	(match_operand:SI 3 "register_operand" "d"))
   (set (match_operand:SI 4 "register_operand" "=d")
	(match_operand:SI 5 "register_operand" "d"))
   (set (match_operand:SI 6 "register_operand" "=d")
	(match_operand:SI 7 "register_operand" "d"))]
  "((get_regno (operands[0]) & 3) == 0)
   && ((get_regno (operands[1]) & 3) == 0)
   && (get_regno (operands[0]) + 1 == get_regno (operands[2]))
   && (get_regno (operands[1]) + 1 == get_regno (operands[3]))
   && (get_regno (operands[0]) + 2 == get_regno (operands[4]))
   && (get_regno (operands[1]) + 2 == get_regno (operands[5]))
   && (get_regno (operands[0]) + 3 == get_regno (operands[6]))
   && (get_regno (operands[1]) + 3 == get_regno (operands[7]))"
  "*
{
  return i960_out_movq(operands[0], operands[1]);
}")

;; Matched 4/17/92
(define_peephole
  [(set (match_operand:DI 0 "register_operand" "=t")
	(match_operand:DI 1 "register_operand" "t"))
   (set (match_operand:DI 2 "register_operand" "=t")
	(match_operand:DI 3 "register_operand" "t"))]
  "((get_regno (operands[0]) & 3) == 0)
   && ((get_regno (operands[1]) & 3) == 0)
   && (get_regno (operands[0]) + 2 == get_regno (operands[2]))
   && (get_regno (operands[1]) + 2 == get_regno (operands[3]))"
  "*
{
  return i960_out_movq(operands[0], operands[1]);
}")

;; Matched 4/17/92
(define_peephole
  [(set (match_operand:DI 0 "register_operand" "=t")
	(match_operand:DI 1 "register_operand" "t"))
   (set (match_operand:SI 2 "register_operand" "=d")
	(match_operand:SI 3 "register_operand" "d"))
   (set (match_operand:SI 4 "register_operand" "=d")
	(match_operand:SI 5 "register_operand" "d"))]
  "((get_regno (operands[0]) & 3) == 0)
   && ((get_regno (operands[1]) & 3) == 0)
   && (get_regno (operands[0]) + 2 == get_regno (operands[2]))
   && (get_regno (operands[1]) + 2 == get_regno (operands[3]))
   && (get_regno (operands[0]) + 3 == get_regno (operands[4]))
   && (get_regno (operands[1]) + 3 == get_regno (operands[5]))"
  "*
{
  return i960_out_movq(operands[0], operands[1]);
}")

;; Matched 4/17/92
(define_peephole
  [(set (match_operand:SI 0 "register_operand" "=d")
	(match_operand:SI 1 "register_operand" "d"))
   (set (match_operand:SI 2 "register_operand" "=d")
	(match_operand:SI 3 "register_operand" "d"))
   (set (match_operand:DI 4 "register_operand" "=t")
	(match_operand:DI 5 "register_operand" "t"))]
  "((get_regno (operands[0]) & 3) == 0)
   && ((get_regno (operands[1]) & 3) == 0)
   && (get_regno (operands[0]) + 1 == get_regno (operands[2]))
   && (get_regno (operands[1]) + 1 == get_regno (operands[3]))
   && (get_regno (operands[0]) + 2 == get_regno (operands[4]))
   && (get_regno (operands[1]) + 2 == get_regno (operands[5]))"
  "*
{
  return i960_out_movq(operands[0], operands[1]);
}");

;; Matched 4/17/92
(define_peephole
  [(set (match_operand:DI 0 "register_operand" "=t")
	(match_operand:DI 1 "register_operand" "t"))
   (set (match_operand:SI 2 "register_operand" "=d")
	(match_operand:SI 3 "register_operand" "d"))]
  "((get_regno (operands[0]) & 3) == 0)
   && ((get_regno (operands[1]) & 3) == 0)
   && (get_regno (operands[0]) + 2 == get_regno (operands[2]))
   && (get_regno (operands[1]) + 2 == get_regno (operands[3]))"
  "*
{
  return i960_out_movt(operands[0], operands[1]);
}")

;; Matched 5/28/91
(define_peephole
  [(set (match_operand:SI 0 "register_operand" "=d")
	(match_operand:SI 1 "register_operand" "d"))
   (set (match_operand:SI 2 "register_operand" "=d")
	(match_operand:SI 3 "register_operand" "d"))
   (set (match_operand:SI 4 "register_operand" "=d")
	(match_operand:SI 5 "register_operand" "d"))]
  "((get_regno (operands[0]) & 3) == 0)
   && ((get_regno (operands[1]) & 3) == 0)
   && (get_regno (operands[0]) + 1 == get_regno (operands[2]))
   && (get_regno (operands[1]) + 1 == get_regno (operands[3]))
   && (get_regno (operands[0]) + 2 == get_regno (operands[4]))
   && (get_regno (operands[1]) + 2 == get_regno (operands[5]))"
  "*
{
  return i960_out_movt(operands[0], operands[1]);
}")

;; Matched 5/28/91
(define_peephole
  [(set (match_operand:SI 0 "register_operand" "=d")
	(match_operand:SI 1 "register_operand" "d"))
   (set (match_operand:SI 2 "register_operand" "=d")
	(match_operand:SI 3 "register_operand" "d"))]
  "((get_regno (operands[0]) & 1) == 0)
   && ((get_regno (operands[1]) & 1) == 0)
   && (get_regno (operands[0]) + 1 == get_regno (operands[2]))
   && (get_regno (operands[1]) + 1 == get_regno (operands[3]))"
  "*
{
  return i960_out_movl(operands[0], operands[1]);
}")
