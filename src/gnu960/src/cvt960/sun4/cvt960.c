
/*(c**************************************************************************** *
 * Copyright (c) 1990, 1991, 1992, 1993 Intel Corporation
 * 
 * Intel hereby grants you permission to copy, modify, and distribute this
 * software and its documentation.  Intel grants this permission provided
 * that the above copyright notice appears in all copies and that both the
 * copyright notice and this permission notice appear in supporting
 * documentation.  In addition, Intel grants this permission provided that
 * you prominently mark as "not part of the original" any modifications
 * made to this software or documentation, and that the name of Intel
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software or the documentation without specific,
 * written prior permission.
 * 
 * Intel Corporation provides this AS IS, WITHOUT ANY WARRANTY, EXPRESS OR
 * IMPLIED, INCLUDING, WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY
 * OR FITNESS FOR A PARTICULAR PURPOSE.  Intel makes no guarantee or
 * representations regarding the use of, or the results of the use of,
 * the software and documentation in terms of correctness, accuracy,
 * reliability, currentness, or otherwise; and you rely on the software,
 * documentation and results solely at your own risk.
 * 
 * IN NO EVENT SHALL INTEL BE LIABLE FOR ANY LOSS OF USE, LOSS OF BUSINESS,
 * LOSS OF PROFITS, INDIRECT, INCIDENTAL, SPECIAL OR CONSEQUENTIAL DAMAGES
 * OF ANY KIND.  IN NO EVENT SHALL INTEL'S TOTAL LIABILITY EXCEED THE SUM
 * PAID TO INTEL FOR THE PRODUCT LICENSED HEREUNDER.
 * 
 ***************************************************************************c)*/

#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <ctype.h>

#if !defined( APOLLO400 ) && ! defined ( __GCC960 )
/* For some reason if you #include <string.h> AND #include <memory.h> in either order,
   on the Apollo 400, the compiler gets a multi definition error. */
#include <memory.h>
#endif

#include "695_out.h"

#include "err_msg.h"
#include "sgs.h"
#include "ldfcn.h"
#include "bfio.h"

/****************************************************************************/

extern void usage();
extern char *ldgetname(), *calloc();
extern void Getvinfo();
extern int filesame();

/******************************************************************************/

extern int minrev; /* exported by vers.c; generated by make */
extern unsigned init_n; /* exported by 695_out.c */
extern unsigned next_n; /* exported by 695_out.c */
#define NN_FIRSTDYN     34

/****************************************************************************/

/* #define	 DEBUG */
#if defined(__GCC960) || defined(SYSV) || defined(MSDOS) 
/* patch up BSD/SYSV differences w.r.to STRING(3C) */
#define	index(cp,ch)	strchr(cp,ch)
#define rindex(cp, ch)	strrchr(cp, ch)
#endif

#ifndef bool
#define bool      char
#endif
#define OK        0
#define EXIT_OK   0
#define FAIL      1
#define EXIT_FAIL 1
#define TRUE      1
#define FALSE     0
#define RESTRICTED TRUE
#define UNRESTRICTED (!RESTRICTED)
#define ON        1
#define OFF       0
#define MAXAUTO_SPATH 16

/*
 * COFFREG_*:
 * Boundary n_value contents for C_REG and C_REGPARM symbols, and a 
 * distinguished invalid value.
 */
#define COFFREG_R0 0
#define COFFREG_G15 0x1F
#define COFFREG_INVALID -1

#define CHKFREE(p) {if ((p) != NULL) {free((p)); (p) = NULL;}}

#define IS_TAGSYMPTR(symptr)  ( ISTAG((symptr)->n_sclass) )

/* CORESYMPTR
 * Assuming that COFF symbols at indices 'corebase'...'symindex'
 * have been allocated to the core array at 'corearr', produce a
 * pointer to the COFF symbol
 * at symbol table index 'symindex'.
 */
#define CORESYMPTR(corearr, corebase, symindex) \
  ((corearr) + ((symindex)-(corebase)))
#define COREAUXPTR(corearr, corebase, symindex) \
   ((AUXENT *)CORESYMPTR(corearr, corebase, symindex))

/* VALID_AUX_RANGE
 * u is an unsigned number.  A valid number of aux entries is <= 3.
 */
#define VALID_AUX_RANGE(u) ((u) <= 3 )

/* VALIDNUMAUX
 *
 * Returns a valid number of aux entries, or aborts with an error message
 * about an invalid symbol table, citing the symindex that contained the
 * numaux.
 */
#define VALIDNUMAUX(symindex, numaux) \
   (VALID_AUX_RANGE((unsigned char)(numaux))?(unsigned char)(numaux) \
                                          :abort_bad_numaux((symindex),\
							    (numaux)))
/*
 * IS_ARG
 *    TRUE if the symbol represents a "C" function argument, no matter
 *    where it may be allocated.  Note that this implementation admits
 *    the pseudo-argument '.argptr'.
 */
#define IS_ARG(symbol) \
   ((symbol).n_sclass == C_AUTOARG /* lives in callee's frame */\
    || (symbol).n_sclass == C_ARG  /* lives in caller's frame */\
    || (symbol).n_sclass == C_REGPARM) /* lives in register */

/*
 * BITYPTR_OFFSET
 * Adding 'pointer to unknown' to a non-pointer member of HPBITY_*
 * effectively converts to one of the single-dereference HPBITY_*,
 * i.e. the HPBITY_P_*.
 */
#define BITYPTR_OFFSET HPBITY_P_UNK

#define DTMAX 13 /* maximum number of DT_* within a COFF symbol's type */
#define FIRST_HL_INDEX 256 /* The first high-level 695 type index */
#define UCHAR_BITS (8*sizeof(unsigned char))

/* Memory Section IDs [1..MAX_SCNS] are allowed */
#define MAX_SCNS 64
 
/* IS_TAG_DEFD
 * If the 695 index associated with coff index 'i' is an already-defined
 * tag, TRUE.
 */
#define IS_TAG_DEFD(i)   (hltype_index(i)->tagdef != 0) 

#define DEF_TAG(i) \
  { HLINDEX *h = hltype_index(i); h->tagdef = TRUE; }

/* TYPE_HANDLE
 * The handle associated with the COFF index of an object-symbol
 * or a tag-symbol.
 */
#define TYPE_HANDLE(symindex)  (hltype_index(symindex) -> i695)


#define IS_FILE(symbol) ((symbol).n_sclass == C_FILE)

#define IN_SECTION(symbol) ((symbol).n_scnum > 0)

#define IS_LEAF_PROC(symbol) ((symbol).n_sclass == C_LEAFEXT \
			      || (symbol).n_sclass == C_LEAFSTAT)

/* IS_SPECIAL_PROCEDURE defines the function symbols with 2 aux entrys
 * rather than the usual 1.
 */
#define IS_SPECIAL_PROCEDURE(symbol) \
   (IS_LEAF_PROC(symbol) || (symbol).n_sclass==C_SCALL)


/* IS_SEC_GLOBAL
 * TRUE if we have an external or a function in a memory section.
 * Note that IS_SEC_GLOBAL symbols are a subset of IS-695_XLATABLE
 * symbols.  
 */
#define IS_SEC_GLOBAL(symbol) \
   (IN_SECTION(symbol) &&\
      ((symbol).n_sclass == C_EXT  \
       ||  (symbol).n_sclass == C_LEAFEXT\
       || (symbol).n_sclass == C_SCALL))

/* IS_ABSOLUTE identifies symbols which are outside the scope of a section;
 * for example _etext, _edata and _end, or also symbols which the user
 * can define with LNK960.
 */
#define IS_ABSOLUTE(symbol) \
   (((symbol).n_scnum==-1)  &&  ((symbol).n_sclass==C_EXT))

/* Publics are either global symbols in a memory section, or else absolutes
 * which lie in no section.
 */
#define IS_695_PUBLIC(symbol) (IS_ABSOLUTE(symbol)  ||  IS_SEC_GLOBAL(symbol))

/* IS_FLOCAL => local to a function scope; a useful class for
 * 695 translation.  Note however that this also admits the pseudo-local
 * symbol '.target'.
 */
#define IS_FLOCAL(symbol) \
   (((symbol).n_sclass == C_AUTO)    /* automatic at fp-offset */\
    ||((symbol).n_sclass == C_REG)   /* automatic in register */\
    ||(IS_ARG(symbol)))
  
/* IS_695_XLATABLE
 * TRUE if we have an external or a leafproc in a memory section,
 * or else TRUE if we have a static of non-null type, or a label.
 */
#define IS_695_XLATABLE(symbol) \
   (  IS_SEC_GLOBAL(symbol)\
      || IS_FLOCAL(symbol)\
      || IN_SECTION(symbol)  &&\
         ((((symbol).n_sclass == C_STAT && (symbol).n_type != T_NULL) &&\
	   !is_section_info(&(symbol)))\
	  ||\
	  ((symbol).n_sclass == C_LABEL)\
	  ||\
	  ((symbol).n_sclass == C_LEAFSTAT)))
			    
/* IS_695_ASMSTAT is effectively IS_695_XLATABLE without
 * arguments and autos, and with the
 * restriction on C_STAT with T_NULL type.
 */
#define IS_695_ASMSTAT(symbol) \
   (IN_SECTION(symbol)  &&\
    (\
     (symbol).n_sclass==C_EXT  ||\
     (symbol).n_sclass == C_LABEL ||\
     IS_SPECIAL_PROCEDURE(symbol) ||\
     ((symbol).n_sclass==C_STAT &&\
      !is_section_info(&(symbol)))))

/*
 * IS_695_GLOBAL is typically C_EXT sclass, but some special functions are
 * implicitly global as well.
 */
#define IS_695_GLOBAL(symbol) \
   (symbol.n_sclass==C_EXT\
    ||symbol.n_sclass==C_LEAFEXT\
    ||symbol.n_sclass==C_SCALL)

/* IS_NONSCALAR
 *    Is the symbol an array, structure, union, or enumeration.
 */
#define IS_NONSCALAR(symbol) \
   (ISARY((symbol).n_type)\
    || (BTYPE((symbol).n_type) == T_STRUCT)\
    || (BTYPE((symbol).n_type) == T_UNION)\
    || (BTYPE((symbol).n_type) == T_ENUM))
   
/* IS_HL_LABEL
 * Assume that sym is a label.
 * A high-level label depends on its source module context and its
 * first character.  This is admittedly heuristic.
 */
#define IS_HL_LABEL(sym) \
   (inside_HLmodule  &&  (*(sym) == '_'  || isalpha(*(sym))))

/* IS_BITY_XLATABLE is true if a base type has a well-defined translation
 * to a 695 Built In Type.  A boundary-case is that of T_NULL; this
 * predicate returns true for T_NULL, since it can reasonably be
 * translated to the 695 BITY_UNK type.
 */
#define IS_BITY_XLATABLE(btype)  (!(\
       ((btype)==T_STRUCT)||\
       ((btype)==T_UNION)||\
       ((btype)==T_ENUM)||\
       ((btype)==T_MOE)      ))

/*
 * DT_KIND
 * Given a COFF symbol's type field, and the index into the DT_* fields
 * within it, return the contents of the indicated field: one
 * of (DT_ARY, DT_FCN, DT_PTR, DT_NON).  Note that the dti index is
 * origin-1; 1 is the DT returned by ISFCN(), ISPTR(), etc.
 */
#define DT_KIND(type, dti) (\
      ((type)   >>  (N_BTSHFT + (((dti)-1) << 1)))\
      &\
      (DT_NON|DT_ARY|DT_FCN|DT_PTR) )

/* IS_COFF_SEGMENT_NAME
 * A coff segment name is one of (".text", ".data", ".bss", ".bss2")
 * These usually map to the standard memory sections of the same name,
 * but LNK960 can make them map to arbitrarily named sections.
 *
 * UPDATE: this function will not recognize user-defined segments
 * as introduced by 960 tools R3.
 */
#define IS_COFF_SEGMENT_NAME(symbol_name)\
   ((*(symbol_name) == '.') &&\
    (!strcmp((symbol_name)+1, "text")\
     ||\
     !strcmp((symbol_name)+1, "data")\
     ||\
     !strcmp((symbol_name)+1, "bss")))
     /* support for .bss2, is removed.  There is now no support for */
     /* the saguoro project in this code. */


/*
 * PTR_TO_BITY
 * Given a 695 Built In TYpe which is NOT a pointer, convert it to
 * the B.I.TY. code which represents pointer to the parameter.  For example,
 * when bity = 2, return 2+HPBITY_P_UNK, i.e. 34.
 */
#define PTR_TO_BITY(bity) ((bity) + BITYPTR_OFFSET)

/* Number of hash buckets for coff-index / tag index association. */
#define NBUCKETS 17

#define HLHASH(i) ((i)%NBUCKETS)

#define FIRST_HL_HANDLE 0x100

#define SHF_CONTENT	(STYP_TEXT|STYP_DATA|STYP_BSS)
#define SHF_LINKATT \
	(STYP_REG|STYP_DSECT|STYP_NOLOAD|STYP_GROUP|STYP_PAD|STYP_COPY)

/* IS_DIR_DELIM defined for MS_DOS or UNIX */
#ifdef MSDOS
#define IS_DIR_DELIM(c) ((c) == '/'  ||  (c) == '\\')
#else
#define IS_DIR_DELIM(c) ((c) == '/')
#endif

/******************************************************************************/
typedef struct hltype_index_tag {
   struct hltype_index_tag *next; /* must be 1st member; see hltype_index()*/
   bool tagdef; /* true if i695 references an emitted 695 type tag */
   long icoff;  /* coff index associated with tag or derivation */
   HPTYPEHANDLE i695; /* 695 index associated with tag or derivation */
} HLINDEX;

typedef struct extref_tag { /* element in an EXTLIST */
   SYMENT *sym;
   struct extref_tag *next;
   struct extref_tag *prev;
} EXTREF;

typedef struct extlist_tag { /* list of refs to an array of SYMENTs. */
   EXTREF head; /* associated with vfirst */
   EXTREF tail; /* associated with vlast */
   SYMENT vfirst; /* <= any external symbol */
   SYMENT vlast;  /* >= any external symbol */
   EXTREF *cur_ref; /* supports iteration through list */
} EXTLIST;

/****************************************************************************/
/* Data associated with command line */
static char ignoresymbols_flag;
static char ignorewarns = FALSE;
static char had_pix_error = FALSE;
static char *outfile_name, *infile_name;
static LDFILE* inldfile_ptr;
static FILE *infile_ptr;
/* -v960 not listed in options, because it's existence is checked */
/* before any call to getopt() */
static char options[] = "acwshVzo:i:A:";
static char defaultinfile_name[]  = "a.out";


/* comment_buf is large enough to hold the tool's version,
 * and the SIGMA Header fields for cvt960.c and 695_out.c
 * This comment is placed in the 695 module to help version control.
 */
static char comment_buf[160];
static char ie_version[] = "$File: cvt960.c $ $Version: 1.27 $";

static char *error_prefix;

static long cur_argptr = COFFREG_INVALID;

static struct sec_info_type {

   long  sec_flags;
   char* sec_name;
   unsigned long  sec_size;
   LOGADR960  sec_paddr;
   EXTLIST globlist;
} sec_info[MAX_SCNS + 1];
/* sentinel_symindex
 * A nonzero value N means that there are N entrys in the symbol
 * table to be processed (also interpreted as the index beyond the
 * last valid symbol table index).  N==0 means either there were no
 * symbols, or we have been directed to ignore them.
 */
static long sentinel_symindex = 0;

static long ext_mod_index = -1;   /* index to external part of symbol table */
static SYMENT* ext_mod_ptr = NULL;/* points to the array of external symbols
                               * from the symbol table.
                               */

HPTYPEHANDLE next_handle = FIRST_HL_HANDLE;

/* hash on coff symindex with associated 695 h/l type index */
static HLINDEX *bucket[NBUCKETS]; 

static long             endlnptr    = 0L;
static long             currlnnoptr = 0L;
static short            not_end_of_lnno = 0;

/******************************************************************************/
static HLINDEX *hltype_index();

static SYMENT *read_alloc_mod(), *bread_alloc_mod(), *alloc_tag();

static bool 
 is_bb(), is_bf(), is_eb(), is_ef(), is_section_info(),
 is_tag_reference(), is_derived_xlat(), gen_attribute(), is_tagi(),
 fcn_has_a_block();

static char hp_bity_of();

static char *ldget_f_name(), *get_command_line(), *chkalloc(),
  *translate_tagname(), *file_name(),
/* *match_toolname(), */
  *tool_version();

static unsigned short xlat_coffreg();

static int setflags(), emit_b10sym(), linit(), lnext();

static unsigned char abort_bad_numaux();

static void cvt960_abort(),
   convert_to_695(),
   free_ext_symbols(),
   init_ext_symbols(),
   free_ext_symbols(),
   free_ext_range(),
   find_ext_range(),
   insert_ext_symbol(),
   read_symbol_with_index(),
   define_tag(), define_derivation(), define_unktag(),
   put_procmark();

/* Method of initializing a range of indices */
static void undefine_types();
   
static long first_ext_symbol(), next_ext_symbol();

static HPTYPEHANDLE hl_type(), base_handle_of(), ptr_to_bity();

static unsigned long function_limit;
int amc_mri = FALSE;	/* if true add 1 to section size and
			 * do not strip suffix from module name
			 * Required to make 695 output work with
			 * AMC 80960CA ICE
			 */

int column_zero = FALSE;  /* Lots of confustion regarding whether column 0 in
			      a line number means 'the compiler does not care about
			      line numbers'.  This is here so the user can actually
			      toggle between one (the defualt) or zero. */
			      
int architecture;  /* set to non-NULL if user specified -A switch */

/******************************************************************************/


static int linit(fcnindx)
long            fcnindx;
{
    SCNHDR              secthead;
    SYMENT              symbol;
    AUXENT              aux;
    LINENO              line;
    long                lnnoptr ;

    not_end_of_lnno = 0;

    if (ldtbread(inldfile_ptr, fcnindx, &symbol) != SUCCESS)
       return FAILURE;

    if (!ISFCN(symbol.n_type) || (symbol.n_numaux <= 0))
       return FAILURE;

    if (FREAD(&aux, AUXESZ, 1, inldfile_ptr) != 1)
      return FAILURE;

    if (ldshread(inldfile_ptr, symbol.n_scnum, &secthead) != SUCCESS)
      return FAILURE;

    function_limit = (unsigned long) symbol.n_value + 
		     (unsigned long) aux.x_sym.x_misc.x_fsize - 1;

    lnnoptr = aux.x_sym.x_fcnary.x_fcn.x_lnnoptr;

    if (lnnoptr == 0)
       return FAILURE;

    endlnptr = secthead.s_lnnoptr + (long) (secthead.s_nlnno * LINESZ);

    if ((secthead.s_lnnoptr>lnnoptr)  ||  (lnnoptr + LINESZ > endlnptr))
       return FAILURE;

    /* lnnoptr is greater or equal to s_lnnoptr
     * and less than endlnnoptr by at least as much as LINESZ
     */

    if (FSEEK(inldfile_ptr, lnnoptr, BEGINNING) != OKFSEEK)
       return FAILURE;

    if (FREAD(&line, LINESZ, 1, inldfile_ptr) != 1)
       return FAILURE;

    if ((line.l_lnno != 0)  ||  (line.l_addr.l_symndx != fcnindx))
       return FAILURE;

    currlnnoptr = bftell(IOPTR(inldfile_ptr));
    not_end_of_lnno = 1;
    return SUCCESS;

}

/*
 * fcn_has_a_block
 *    IS_FCN(symbol at symindex) is assumed on entry.
 *    Return TRUE if the symbols for the function include
 *    a '.bf'.  The presence of the bf is taken to mean that there
 *    was debug information generated for this function (with -g).
 */
static bool fcn_has_a_block(curr_mod_ptr, first_mod_symindex, 
                            last_mod_symindex, symindex)
   SYMENT *curr_mod_ptr;
   long    first_mod_symindex;
   long    last_mod_symindex;
   long    symindex;
{
   SYMENT *symptr; 
   long exclusive_end_index =
      COREAUXPTR(curr_mod_ptr, first_mod_symindex, symindex+1)
         ->x_sym.x_fcnary.x_fcn.x_endndx;

   if (exclusive_end_index > (last_mod_symindex+1)) {
      /* THE END OF THE FUNCTION'S SYMBOLS IS BEYOND THE END OF THE
       * MODULE.  THE FUNCTION'S INFORMATION ABOUT THIS TOPIC IS INVALID.
       *
       * KLUDGE
       * There should be a warning generated in the future here.
       *
       * We state that the function has no block and hope for the best...
       * (One reason that the function's size is invalid is that it was
       * stripped... and the aux entry was not updated.
       * and hence has no blocks).
       */
      return FALSE;
   }

   symptr = CORESYMPTR(curr_mod_ptr, first_mod_symindex, symindex);

   for (;;) {

      symindex += VALIDNUMAUX(symindex, symptr->n_numaux) + 1;
      if (symindex >= exclusive_end_index) 
         return FALSE; /* did not find a bf */

      symptr = CORESYMPTR(curr_mod_ptr, first_mod_symindex, symindex);
      if (is_bf(symptr))
         return TRUE; /* found a bf */
      
   }
}

/*
 * FUNCTION: lnext
 *
 * PARAMETERS:
 *     linent - Pointer to the line number entry filled in by this function.
 *
 * DESCRIPTION:
 *     Returns the next line number entry for the function being examined.
 *     The current function for which line number entries are being processed
 *     is set by linit.  Each successive call to lnext returns the next
 *     line number entry for the function.  lnext stops reading line
 *     numbers for the current function when the initial entry for the next
 *     function is reached or the end of the line number table is reached.
 *
 * RETURN VALUES:
 *     SUCCESS is returned if the next line number is successfully read.
 *     Otherwise, FAILURE is returned.
 *
 * NOTES:
 *     lnext does not distinguish a failure
 *     due to the end of the line number list for a function being reached
 *     from a failure due to a bad I/O call status.  This issue should be
 *     examined in the future.
 *
 */

static int lnext(linent)
LINENO          *linent;
{
   /* All line number entries for current function already processed. */
   if (not_end_of_lnno == 0)
        return(FAILURE);

   /* Make sure we do not read past the end of the line number table. */
   if ((currlnnoptr + LINESZ) > endlnptr) {
        not_end_of_lnno = 0;
        return(FAILURE);
   }

   /* Seek to the correct location in the COFF file if not already there. */
   if (bftell(IOPTR(inldfile_ptr)) != currlnnoptr)
        if (bfseek(IOPTR(inldfile_ptr), currlnnoptr, 0) != 0)
                return(FAILURE);

   /* Read the next line number entry. */
   if (FREAD(linent, LINESZ, 1, inldfile_ptr) != 1)
        return(FAILURE);

   /* see if line number value is outside of current function */
   /* this check is work-around for compiler bug where extra linenumber */
   /* was emitted outside of fuinction code */
   /* Return failure state if all line numbers read for current function. */
   if (linent->l_addr.l_paddr > function_limit || linent->l_lnno == 0) {
        not_end_of_lnno = 0;
        return(FAILURE);
   }
   /* Update the current line number pointer */
   currlnnoptr = bftell(IOPTR(inldfile_ptr));

   return(SUCCESS);
}

static char *cvt960_abort_filename;
static int   cvt960_abort_linenumber;

static void cvt960_abort()
{
    extern int error_count;

    if (error_count == 0 && cvt960_abort_filename)
	    fprintf(stderr,"%s: Internal error: (%s:%d)\n",error_prefix,
		    cvt960_abort_filename,cvt960_abort_linenumber);
    hp_abort();
    exit(EXIT_FAIL);
}

#define abort() cvt960_abort_filename = __FILE__,cvt960_abort_linenumber = __LINE__,cvt960_abort()

/*
 * chkalloc: malloc with an error-print and cleanup-exit on NULL result.
 */
static char *chkalloc(size)
   unsigned size;
{
   char *mallocr = (char *) malloc(size);
   if (mallocr == NULL) {
      error_out(error_prefix, ALLO_MEM, NO_SUB);
      abort();
   }

   return mallocr;
}


/* abort_bad_numaux
 *
 * An invalid numaux value has been encountered at symindex, or else if
 * symindex is out of range, the bad numaux was encountered at an unknown
 * symindex.
 *
 * NOTE: this should be void (there is no return at all), but is unsigned char
 * because of caller context.
 */
static unsigned char  abort_bad_numaux(symindex, numaux)
   long symindex;
   unsigned char numaux;
{
   char tmp[30];
   /* NOTE! The following is a prototype message, real message should
    * be done with error_out.
    */
   if (symindex < 0) {
      strcpy(tmp, "unknown");
   } else {
      sprintf(tmp, "%d", symindex);
   }
   error_out(error_prefix, BADAUX, NO_SUB, tmp, numaux);
   abort();
}
   

/*
 * Return a pointer to the beginning of the file name within path name 
 * 'path_name'.  This only handles DOS and UNIX path names now.
 */
static char *file_name(path_name)
   char *path_name;
{
   char *fnbegin = path_name;

   while (*path_name) {
      if (IS_DIR_DELIM(*path_name))
         fnbegin = ++path_name;
      else
         ++path_name;
   }

   /* fnbegin points either to path_name, or beyond the end of the
    * last delimiter if there were any delimiters.
    */
   return fnbegin;
}

/*
 * put_procmark
 *
 * For the storage classes which represent special procedure symbols
 * (C_LEAFEXT, C_LEAFSTAT, C_SYSPROC), use the auxinfo variable to
 * define either a VMISC or PMISC record.
 */
static void put_procmark(context, sclass, auxinfo)
   int context;       /* in which to write the misc record */
   int sclass;        /* either public leaf, private leaf, or sysproc */
   long auxinfo;      /* bal-call offset, or system index */
{
   static MISCARGPTR argv[2] = { {FALSE}, {FALSE} };
   unsigned long proc_type; /* 695 sysproc/leafproc flag */
   
   switch (sclass) {
      case C_LEAFEXT:
      case C_LEAFSTAT: 
      proc_type = HP960PROC_LEAF;
      break;
      
      case C_SCALL:
      proc_type = HP960PROC_SYS;
      break;
      
      default:
      return; /* should never occur */
   }

   /* Although MNUMPTR nominally points to unsigned long, a long
    * auxinfo causes no problems because we never do arithmetic with it.
    */
   argv[0].MNUMPTR = &proc_type;
   argv[1].MNUMPTR = (unsigned long *)&auxinfo;
   /* code 63, proc_type, system_index | bal_address */
   if (hp_mark(context, HPMISC_960CALL, 2 /* args */, argv) < 0)
      abort();
}

typedef struct source_mod_tag {
    long first_index; /* index to the first symbol of the module */
    long last_index;  /* last valid index in the module */
    struct source_mod_tag *next; /* next source module index pair */
} SOURCE_MOD;

/*
 * define_unktag
 *
 * The caller asserts that the symbol at symindex has an invalid x_tagndx
 * link of value 'tagindex'.  However, the symbol's aux entry has provided
 * the 'size' of the type, which allows us to do the following here:
 *
 *     * Define the type as Unknown Sized.
 *     * Print a warning about the reference seen.
 *
 * NOTE: this handling assumes
 * that any other bogus tag reference within the
 * module or .global_non_init refers to the same real tag.  Also, it
 * will not produce warning messages for subsequent references to the
 * erroneous tag index (i.e. from other symbols).
 */
static void define_unktag(symindex, tagindex, size, source_mod_ptr)
   long symindex; /* the index of the symbol with unknown tag type. */
   long tagindex; /* the bogus value in the symbol's aux entry */
   unsigned long size; /* the size of the symbol in MAUs */
   SOURCE_MOD *source_mod_ptr;
{
   HPHITYPE hp_type;

   if (((HEADER(inldfile_ptr)).f_flags) & F_COMP_SYMTAB) {
       /* If the file has a compressed symbol table, let's see if we can
	  find a tag at the named index. */
       for (;source_mod_ptr != NULL;source_mod_ptr = source_mod_ptr->next)
	       if (tagindex > source_mod_ptr->first_index &&
		   tagindex < source_mod_ptr->last_index)
		       break;
       if (source_mod_ptr) {
	   SYMENT *curr_mod_ptr = bread_alloc_mod(source_mod_ptr->first_index, source_mod_ptr->last_index);
	   if (IS_TAGSYMPTR(CORESYMPTR(curr_mod_ptr,
					      source_mod_ptr->first_index,tagindex))) {
	       define_tag(curr_mod_ptr,source_mod_ptr->first_index, source_mod_ptr->last_index,
				    tagindex);
	       
	       CHKFREE(curr_mod_ptr);
	       return;
	   }
	   CHKFREE(curr_mod_ptr);
       }
   }
   DEF_TAG(tagindex);
   
   hp_type.name = NULL;
   hp_type.selector = HPHITY_UNK;
   hp_type.descriptor.unk = size;

   if (hp_patchtype(&hp_type, TYPE_HANDLE(tagindex)) < 0)
      abort();

   /* we print a warning about the symbol at symindex with bad tag
    * index tagindex.
    */
   if (!ignorewarns)
      warn_out(error_prefix, INVTAGNDX, NO_SUB, symindex, tagindex );
}

static bool is_tagi(symindex)
   long symindex;
{
   SYMENT symbol;
   
   read_symbol_with_index(symindex, &symbol);
   return IS_TAGSYMPTR(&symbol);
}

static void undefine_types()
{
   int i;

   for ( i=0; i < NBUCKETS; i++ ) {
      HLINDEX *p = bucket[i];

      while (p != NULL) {
	 HLINDEX *q = p->next;
         free(p);
         p = q;
      }
      bucket[i] = NULL;
   }
}

/* hltype_index
 * Defines (or references the preexisting definition of) 
 * a pair which associates the coff index parameter
 * with a 695 H/L type index.
 */
static HLINDEX *hltype_index(icoff)
   long icoff;
{
   long hash = HLHASH(icoff);
   HLINDEX *prev_pair = (HLINDEX*)&bucket[hash];
   HLINDEX *cur_pair = prev_pair->next;
   
   for (;;) {
      if (cur_pair == NULL ) {
	 cur_pair = (HLINDEX *)chkalloc(sizeof(HLINDEX));
	 cur_pair->tagdef = FALSE;
	 cur_pair->icoff = icoff;
	 cur_pair->i695 = next_handle++;
	 cur_pair->next = bucket[hash];
	 return bucket[hash] = cur_pair;
      } else if  (cur_pair->icoff == icoff) {
	 prev_pair->next = cur_pair->next;
	 cur_pair->next = bucket[hash];
	 return bucket[hash] = cur_pair;
      } else {
	 cur_pair = (prev_pair = cur_pair) ->next;
      }
   }
}

/*
 * create_hpvers
 *
 * 695 is defined to represent version information in the form "i.j<letter>".
 * 960 tools represent version information in the forms "i.j".
 * This function maps the Intel representation,
 */
static void create_hpvers( vstr, hpvptr )
   char *vstr;
   HPTOOL_VERS *hpvptr;
{
   int version;
   int revision;
   sscanf(vstr, "%d.%d", &version, &revision);
   hpvptr->version = (unsigned short)version;
   hpvptr->revision = (unsigned short)revision;
   hpvptr->level = '\0'; 
}


/*
 * gen_attribute
 *
 * On entry, the coff storage class and value are from a symbol in
 * the context of a "C" module.
 * Generate ATN and ASN information based on COFF storage class and
 * value.  Return TRUE if a valid translation was made.
 */
static bool gen_attribute(symindex, sclass, value, atn, asn, in_bf_ef_scope)
   long symindex; /* coff symbol table index, for error printing only. */
   long sclass; /* coff storage class */
   long value;  /* coff symbol value */
   HPSYMATT *atn; /* OUTPUT: 695 ATN information */
   LOGADR960 *asn; /* OUTPUT: 695 ASN information */
   int  in_bf_ef_scope;  /* The symbol at symindex corresponds to a symbol within the .bf / .ef scope. */
{
   
   switch (sclass) {

   /* Static code and variables */
   case C_EXT:
   case C_LEAFEXT:
   case C_SCALL:
      atn->atnid = HPATN_COMPGLOBAL;
      *asn = value;
      break;
      
   /* Live Registers */
   case C_REG:
   case C_REGPARM:
      /* REG and REGPARM are both locked registers
       * (live from the first line of a function to the end).
       */
      if (in_bf_ef_scope) {
	  atn->atnid = HPATN_LOCKREG;
	  atn->att.regid = xlat_coffreg(symindex, value);
      }
      else {
	  if (!ignorewarns)
	          warn_out(error_prefix, REGOUTOFFUNCSCOPE, NO_SUB, symindex);
	  return FALSE;
      }
      break;

   /* Allocated in the callee's frame */      
   case C_AUTO:
   case C_AUTOARG:
      atn->atnid = HPATN_AUTO;
      atn->att.auto_offset = value;
      break; 
      
   /* Allocated in the caller's frame */
   case C_ARG:
      /* Expression of an argument in the argblock
       * can be done if the argument block pointer is known to be in a
       * register, otherwise it is too complicated to express explicitly
       * in 695 at this time.
       */
      if (cur_argptr == COFFREG_INVALID) {
         if (!ignorewarns)
	    warn_out(error_prefix, ARGBLKARG, NO_SUB, symindex );
	 return FALSE; /* The translation is invalid */
      } else {
	 atn->atnid = HPATN_BASVAR;
	 atn->att.base.offset = value;
	 atn->att.base.control = BASVAR_REG;
	 atn->att.base.global = '\0'; /* local */
	 *asn = cur_argptr;
	 break;
      }
   /* Local code */
   case C_LABEL:
      /* Fall through to the default case */;

   default:
      atn->atnid = HPATN_COMPSTAT;
      *asn = value;
      break;

   } /* switch */

   return TRUE; /* A valid translation was made */
}

/*
 * Translate a COFF symbol table register value to a 695 register.
 * It is expected that these will only represent R0-R15/G0-G15.
 */
static unsigned short xlat_coffreg(symindex, coffreg)
   long symindex; /* for error reporting only */
   long coffreg; /* n_value field of a symbol; purports to be a register */
{
   if (coffreg < COFFREG_R0  ||  COFFREG_G15 < coffreg) {
      if (!ignorewarns)
         warn_out(error_prefix, ILLREGVAL, NO_SUB, coffreg, symindex);
   } 
     
   return coffreg;  /* This mapping is presently the identity */
}

/*
 * Provide a type handle for the high-level symbol entry *symptr at symindex.
 * The handle is a BITY or a h/l type index, as is appropriate.
 *
 * The caller asserts that *symptr is a valid object to translate.
 */
static HPTYPEHANDLE hl_type(symptr, auxptr, symindex)
   SYMENT *symptr;
   AUXENT *auxptr;
   long symindex;
{
   if (is_derived_xlat(symptr->n_type)) {
      /*
       * A derived type chain is headed by a H/L type whose index is
       * a function of the symbol table index of the object containing
       * the derivation.
       */
      return TYPE_HANDLE(symindex);

   } else if (is_tag_reference(symptr)) {
      /*
       * A tag reference's type is a function of the symbol table index
       * of the tag to which it refers.
       */
      return TYPE_HANDLE(auxptr->x_sym.x_tagndx);

   } else if (symptr->n_sclass == C_LABEL ) {
      /* The caller asserts that this is a high-level label;
       * not an asm label .
       */
      return  HPBITY_J;

   } else if (ISPTR(symptr->n_type)) {
      /*
       * This is a pointer, but !is_derived_type() is true
       * here, implying that we have a pointer to a base
       * type.
       */
      return hp_bity_of(BTYPE(symptr->n_type), UNRESTRICTED)
	 +  BITYPTR_OFFSET ;

   } else {
      /*----  Base type  */
      return hp_bity_of(BTYPE(symptr->n_type), UNRESTRICTED);
   }
}

/*
 * is_tag_reference
 *
 * Return TRUE if symptr REFERS to a struct, union, or enumeration tag.
 * Otherwise FALSE.   This simply means that the base type of the
 * symbol is struct, union or enum and the storage class is not a tag.
 */
static bool is_tag_reference(symptr)
   SYMENT *symptr;
{
   return
      ( BTYPE(symptr->n_type) == T_STRUCT  && symptr->n_sclass != C_STRTAG ) 
	 ||
      ( BTYPE(symptr->n_type) == T_UNION   && symptr->n_sclass != C_UNTAG ) 
	 ||
      ( BTYPE(symptr->n_type) == T_ENUM    && symptr->n_sclass != C_ENTAG ) ;
}

/*
 * Predicate which determines whether the symbol *symptr is an 
 * entity (struct member, "C" variable, "C" function, or whatever)
 * which has a derived type; i.e. has DT_* records in high-order bits
 * of the n_type field.
 */
static bool is_derived_xlat(type)
   long type;
{
   long dt1;

   /* UPDATE: I don't think any filtering on the storage class is necessary
    * here if we assume that the only things which have DT's are 
    * static-duration, functions, and struct/union members.
    */
   if ((dt1 = DT_KIND(type, 1)) == DT_NON) {
      /* no derivation of any kind */
      return FALSE;
   } else if (dt1 != DT_PTR) {
      /*
       * The tightest-bound derivation is not a pointer; this is derived.
       */
      return TRUE;
   } else if (DT_KIND(type, 2)  != DT_NON) {
      /* 
       * The pointer is not the only DT in the chain; this is derived.
       */
      return TRUE;
   } else {
      /*
       * If the single-indirection pointer points to a built in type,
       * we do NOT consider it derived for the purposes of translation.
       */
      return ! IS_BITY_XLATABLE( BTYPE(type) );
   }
}


/*
 * alloc_tag
 *
 * Allocate core and read in all the symbols associated with a tag
 * definition.
 */
static SYMENT *alloc_tag(tagb, ptage)
   long tagb;
   long *ptage;
{
   AUXENT aux;  /* The aux entry of the tag at index tagb */
   int numents; /* number of sym entries composing the tag's def */
   long past_eos; /* the symbol table entry past the .eos */
   SYMENT *seg; /* the allocated core to hold the def */

   read_symbol_with_index(tagb+1, (SYMENT*)&aux);
   past_eos = aux.x_sym.x_fcnary.x_fcn.x_endndx;
   *ptage = past_eos-1;
   numents = past_eos-tagb;
   seg = (SYMENT *)chkalloc(numents*SYMESZ);

   if (fseek(IOPTR(inldfile_ptr), HEADER(inldfile_ptr).f_symptr + tagb * SYMESZ,  0)
       == 0) {
      if (fread(seg, SYMESZ, numents, IOPTR(inldfile_ptr)) == numents)
         /* The file pointer has moved beyond what was read */
         return seg;
   }
   error_out(error_prefix, ER_FREAD, NO_SUB, infile_name);
   abort();
}

/*
 * translate_tagname
 *
 * Transform a COFF tag-name into its 695 equivalent.
 * Return a pointer to the name in dynamic storage for deallocation by
 * the caller.
 * Note: If we ever choose to support the 
 * convention spoken of in 695 Table A-1 Note 2,
 * we will also need to know the storage class of the tag.
 */
static char *translate_tagname( coffname )
   char *coffname;
{
   char *plast_;   /* last '_', or else term NUL of coffname */
   char *xname;    /* 695 translation */
   int xstrlen;     /* strlen of finished xname + 1 */
   
   if (coffname == NULL  ||  *coffname == '.')
      return NULL; /* the tag name does not exist || the tag name is a fake */

   /* Otherwise the COFF tag name is the user's name suffixed with _N */
   plast_ = (char *) rindex(coffname, '_');
   if (plast_ == NULL)
      plast_ = coffname + strlen(coffname); /* pretend nul is a '_' */
   xstrlen = plast_ - coffname;
   xname = (char *)chkalloc(xstrlen+1);
   memcpy(xname, coffname, xstrlen);
   xname[xstrlen] = '\0';
   return xname;
}

static char *__string_table__;

/*
  ldgetname() is like putrid slow.  We replace its implementation IN ALL OF CVT960
  using the following code.
*/

#define ldgetname(x,y) CVT960_GET_NAME(y)

char *
CVT960_GET_NAME(s)
    SYMENT *s;
{
    if ((s->n_flags & F_PTRIZED) == F_PTRIZED)
	    return s->n_ptr;
    else {
	if (s->n_zeroes) {
	    static char name_buff[SYMNMLEN+1];

	    strncpy(name_buff,s->n_name,SYMNMLEN);
	    name_buff[SYMNMLEN] = 0;
	    return name_buff;
	}
	else {
	    s->n_flags |= F_PTRIZED;
	    return s->n_ptr = __string_table__ + (s->n_offset-4);
	}
    }
}

/* 
 * produce a 695 def for the tag defined between [tag_index..index(.eos)]
 * the caller arranges that the entries through the .eos are allocated
 * in a core array, specifically the caller guarantees that the
 * tag's defining symbols are within the core array at mod_ptr,
 * and that the core array corresponds to first_..last_ indices.
 */
static void define_tag(mod_ptr, first_mod_index, last_mod_index, 
   t_index)
   SYMENT *mod_ptr;  /* array of symbols in which to find tag def */
   long first_mod_index, last_mod_index; /* index bounds of ary at mod_ptr */
   long t_index; /* index of the tag in the array at mod_ptr */
{
   HPHITYPE hp_type;
   char *coff_tagname; /* coff's internal tag name. */
   char *hp_tagname; /* translated from the coff tag name. */
   SYMENT symbol;
   AUXENT aux;
   unsigned long curcount = 0; /* count of members */
   TAGMEM *curmemb = NULL;   /* pointer to 695 member */
   long cur_index;

   /* mark this tag as defined first: to avoid infinite recursion */
   DEF_TAG(t_index);

   /* output the 695 type definition for the tag. */

   symbol = *CORESYMPTR(mod_ptr, first_mod_index, t_index);
   aux = *COREAUXPTR(mod_ptr, first_mod_index, t_index+1);

   switch (symbol.n_sclass) {
   case C_ENTAG:
      hp_type.selector = HPHITY_CENUM;
      break;

   case C_STRTAG:
      hp_type.selector = HPHITY_STRUCT;
      break;

   case C_UNTAG:
      hp_type.selector = HPHITY_UNION;
      break;

   default:
      return;
   }

   hp_type.name = 
      translate_tagname(ldgetname(inldfile_ptr, &symbol));
   hp_type.descriptor.tag.size
      = aux.x_sym.x_misc.x_lnsz.x_size; /* size of type in MAUs */

   /*
    * This pass through the members counts them and recursively defines
    * any tag references and/or type derivations.
    */
   cur_index = t_index;
   for (;;) {
      cur_index += VALIDNUMAUX(cur_index, symbol.n_numaux) + 1;
      symbol = *CORESYMPTR(mod_ptr, first_mod_index, cur_index);
      if ( symbol.n_sclass != C_EOS ) 
	 curcount++ ; /* one more member to process */
      else
	 break; /* EOS => leave loop */
      /* Handle a reference to a possibly undefined tag */
      
      if (is_tag_reference(&symbol) ) {
	 bool tag_defd;
	 long tagb;
	 aux = *COREAUXPTR(mod_ptr, first_mod_index, cur_index+1);
	 tagb = aux.x_sym.x_tagndx;

	 if ( ! (tag_defd = IS_TAG_DEFD(tagb))) {

	    if ( tagb < first_mod_index   ||   last_mod_index < tagb ) {  
	       long tage;
	       SYMENT *tag_ptr;
	       if ( tagb >= 0 && tagb < sentinel_symindex  && 
		   is_tagi(tagb)) {
		  SYMENT *tag_ptr = alloc_tag(tagb, &tage);

		  define_tag(tag_ptr, tagb, tage, tagb);
		  free(tag_ptr);
		  tag_defd = TRUE;
	       }
	    } else if (is_tagi(tagb)) {
	       define_tag(mod_ptr, first_mod_index, last_mod_index,
			  tagb);
	       tag_defd = TRUE;
	    }
	    if (!tag_defd) {
	       define_unktag(cur_index, tagb, aux.x_sym.x_misc.x_lnsz.x_size,(SOURCE_MOD *)0);
	    }
	 }
      } /* if is_tag_reference */
      if (is_derived_xlat(symbol.n_type)) {

	 define_derivation(mod_ptr, first_mod_index, last_mod_index, cur_index,
			   &symbol);
      }
   }
   hp_type.descriptor.tag.membcount  = curcount;
   /* At this point, we have a member count and any tag references in
    * the members have produced types.
    */
   if (curcount > 0) {
      hp_type.descriptor.tag.member 
	 = (TAGMEM *)
	    chkalloc(hp_type.descriptor.tag.membcount*sizeof(TAGMEM));
   } else {
      hp_type.descriptor.tag.member = NULL;
   }
   /*
    * this pass through the members actually translates them.
    */
   symbol = *CORESYMPTR(mod_ptr, first_mod_index, t_index);
   cur_index = t_index;
   for (curmemb = hp_type.descriptor.tag.member;
	curcount > 0;
	curcount--, curmemb++) {
      char *type_name; /* temporary for name of member */

      cur_index += VALIDNUMAUX(cur_index, symbol.n_numaux) + 1;
      /* cur_index accesses the next member */
      symbol = *CORESYMPTR(mod_ptr, first_mod_index, cur_index);
      if (symbol.n_numaux > 0)
	 aux = *COREAUXPTR(mod_ptr, first_mod_index, cur_index+1);

      /* Initalize one member */
      type_name = ldgetname(inldfile_ptr, &symbol);
      if (symbol.n_sclass == C_MOE  &&  *type_name == '_') {
	 /* strip leading underscore from enumeration member */
	 type_name++;
      }
      strcpy(curmemb->name = (char *)chkalloc(strlen(type_name)+1),
	     type_name);
      curmemb->value = symbol.n_value;
      switch (symbol.n_sclass) {
	 /* The type for all members except bitfields is just the normal
	  * h/l type translation of the member.  Bitfield members
	  * need their type generated here, since they fit neither into
	  * the derived category, nor the tag category.
	  */
      case C_MOS:
      case C_MOU:
      case C_MOE:
	 curmemb->type = hl_type(&symbol, &aux, cur_index);
	 break;

      case C_FIELD: 
	 { /* Define a bitfield type to be referenced by the struct member */
         HPHITYPE bf;

	 bf.name = curmemb->name;
	 bf.selector = HPHITY_BITFLD;
	 /* no base type needed for "C"; signed flag completely defines 
	  * the type
	  */
	 bf.descriptor.bitfld.has_basetype = '\0'; 
	 bf.descriptor.bitfld.is_signed = (BTYPE(symbol.n_type) == T_INT);
	 bf.descriptor.bitfld.size = aux.x_sym.x_misc.x_lnsz.x_size;
	 if (0>hp_patchtype(&bf, curmemb->type = next_handle++))
	    abort();
	 /* We have output the bitfield type, and put its index into
	  * the current member's type field.
	  */
         }
	 break;

      default:
         break;
      } 
      /* curmemb->type is defined */
   } /* for */

   /* Output the tag type */
   if (0> hp_patchtype(&hp_type, TYPE_HANDLE(t_index)))
      abort();

   /* Free the contents of the members and the members themselves */
   for (curcount = hp_type.descriptor.tag.membcount,
   	   curmemb = hp_type.descriptor.tag.member;
	curcount > 0;
	curcount--, curmemb++) {

	 CHKFREE(curmemb->name);
   }
   CHKFREE(hp_type.descriptor.tag.member);
   CHKFREE(hp_type.name);
}


/*
 * base_handle_of
 *
 * base_handle_of returns the 695 type handle associated with
 * the base type of the symbol.
 */
static HPTYPEHANDLE base_handle_of(symptr, auxptr)
  SYMENT *symptr;
  AUXENT *auxptr;
{
   if ( is_tag_reference(symptr) ) {
      /* The handle is a function of the tag's value */
      return TYPE_HANDLE(auxptr->x_sym.x_tagndx);

   } else {
      /* The handle is a mapping to the 695 built-in-type codes */
      return (HPTYPEHANDLE)hp_bity_of(BTYPE(symptr->n_type), UNRESTRICTED);
   }
}

/* 
 * Create a structured type definition for 'symbol', which is
 * located in the array at 'mod_ptr' at index 'symindex'.
 * 'first_index' is the initial symbol index in the array at 'mod_ptr'.
 *
 * The structured type definition chain created will end with a type
 * whose index is TYPE_HANDLE(symindex).  Indices within
 * the chain are allocated such that they never conflict with the
 * range of TYPE_HANDLE().
 */
static void define_derivation(mod_ptr, first_index, last_index, symindex, 
                              symptr)
   SYMENT *mod_ptr, *symptr;
   long first_index, last_index, symindex;
{
   HPHITYPE hp_type;
   HPTYPEHANDLE last_handle;
   AUXENT aux;
   unsigned short arydim[DTMAX+1];
   unsigned short *dimptr = NULL;
   short dt_index;
   bool first_dt;

   if (VALIDNUMAUX(symindex, symptr->n_numaux) > 0) {
      aux = *COREAUXPTR(mod_ptr, first_index, symindex + 1);
   }

   hp_type.name = NULL; /* All types within derivations are anonymous,
			 * with the exception of function definitions.
			 */
   
   first_dt = TRUE;      
   last_handle = base_handle_of(symptr, &aux);   

   for ( dt_index = DTMAX; dt_index > 0; dt_index-- ) {
      int error = 0; /* error flag from hp_*type calls */

      switch ( DT_KIND(symptr->n_type, dt_index) ) {

      case DT_NON:
	 /* We have not yet reached the DT's of interest. */
	 continue; /* for loop, leave first_dt FALSE */

      case DT_PTR:
	 if (last_handle <= HPBITY_J) {
	    /* last_handle is a non-pointer BITY */
	    last_handle = PTR_TO_BITY(last_handle);
         } else {
	    /* Emit a high-level type def for a pointer to
	     * the last handle 
	     */
	    hp_type.selector = HPHITY_PTR;
	    hp_type.descriptor.ptr = last_handle;
	    if (dt_index > 1) 
	       error = hp_patchtype(&hp_type, last_handle = next_handle++); 
	    else
	       error = hp_patchtype(&hp_type, TYPE_HANDLE(symindex));
	 }
         break;  /* case DT_PTR */
      
      case DT_ARY:
         hp_type.selector = HPHITY_CARR;
         hp_type.descriptor.carr.membtype = last_handle;
      
         if (dimptr == NULL  &&  symptr->n_numaux != 0) {
	    /* build a stack of the array dimensions in reverse order
	     * of precedence; i.e. column on top, row below.
	     */
	    unsigned short *coffdimptr
	       = &aux.x_sym.x_fcnary.x_ary.x_dimen[0];
	    unsigned short dti;

	    dimptr = &arydim[DTMAX];
	    /* start at first index where an ARY was found */
	    

	    for (dti = dt_index; dti > 0; dti--) {
	       /* for each DT_ARY in the list, push a dim on the stack */
	       if (DT_KIND(symptr->n_type, dti) == DT_ARY) {
		  /* We have found an ARY; push a dim on the stack */
		  dimptr--;
		  if (coffdimptr < 
		      &aux.x_sym.x_fcnary.x_ary.x_dimen[DIMNUM])
		     *dimptr = *coffdimptr++;
		  else /* The x_dimen array is exhausted */
		     *dimptr = 0;
	       }
	    }
	 } /* if dimptr == NULL && <there is an aux entry> */
      
         if (dimptr==NULL) {
	    hp_type.descriptor.carr.high_bound = -1; /* high bound unknown */
	 } else {
	    hp_type.descriptor.carr.high_bound = *dimptr - 1;
	    /* Note that in the case where *dimptr was 0, we store
	     * -1 => high bound unknown.
	     */
	    dimptr++; /* Pop the dim off the stack */
	 }
         if (dt_index > 1)
	    error = hp_patchtype(&hp_type,  last_handle = next_handle++); 
	 else
	    error = hp_patchtype(&hp_type, TYPE_HANDLE(symindex));

         break;  /* case DT_ARY */
      
      case DT_FCN:
         /* initialize attributes, frame type, push mask */
         hp_type.selector = HPHITY_PROCWI;
         /* attributes of the procedure are "standard" */
         hp_type.descriptor.procwi.attribute
	    = (HPPAT_REENT|HPPAT_ROM|HPPAT_NOPUSH);
	 if (IS_LEAF_PROC(*symptr)) {
	    AUXENT *aux2 = COREAUXPTR(mod_ptr, first_index, symindex + 2);
	    long info2 = aux2->x_bal.x_balntry - symptr->n_value;

	    hp_type.descriptor.procwi.attribute |= HPPAT_LEAFP;
	    if ( info2 != 0 ) {
	       /* This is a dual-entry leaf procedure which means we cannot
		* statically know whether it has a frame.
		*/
	       hp_type.descriptor.procwi.attribute |= HPPAT_UNKFRAME;
	    }
	 }
	 /* Default assumption: A known number of args: 0 */
	 hp_type.descriptor.procwi.argcnt = 0;
         hp_type.descriptor.procwi.arglist = NULL; 
         if (dt_index == 1) {
	    /* This is a function definition; look for parameter
	     * info and define in hp_type.arglist.
	     */
	    char *f_name = ldgetname(inldfile_ptr, symptr);
	    if (*f_name == '_')
	       f_name++;
	    /* We can give the type the name of the function */
	    hp_type.name = strcpy((char*)chkalloc(strlen(f_name)+1), f_name);

	    if (fcn_has_a_block(mod_ptr, first_index, last_index, symindex)) {
	       /* We have local symbols defined in this function definition.
		* Search for and process argument symbols.
		*/
	       long index_bound = aux.x_sym.x_fcnary.x_fcn.x_endndx;
	       long cur_index = symindex + symptr->n_numaux + 1;
	       long first_arg_index = -1; /* calcd while incrmntg cur_index */
	       int argcnt = 0;
	       SYMENT symbol;
	       AUXENT aux;
	       HPTYSTR_ARG *next_arg;
	       bool ignore_c_args = TRUE; /* ignore storage class C_ARG */
	       long argptr_index = -1; /* to be replaced by index of .argptr
					* symbol if it exists
					*/

	       while (cur_index < index_bound) {
		  /* get a potential local symbol */
		  symbol = *CORESYMPTR(mod_ptr, first_index, cur_index);
		  if (IS_ARG(symbol)) {
		     if (!strcmp(".argptr", ldgetname(inldfile_ptr, &symbol))) {
			argptr_index = cur_index; /* index of .argptr symbol */
			if (symbol.n_sclass == C_REGPARM) {
			   ignore_c_args = FALSE;
			   /* We have found an argptr that will allow us
			    * to translate C_ARG symbols following.
			    */
			}
		     } else if (symbol.n_sclass == C_ARG && ignore_c_args) {
			/* argument block symbols are ignored */
		     } else {
			if (first_arg_index < 0)
			   first_arg_index = cur_index;
			argcnt++;
		     }
		  }
		  cur_index += VALIDNUMAUX(cur_index, symbol.n_numaux) + 1;
 	       }
	       hp_type.descriptor.procwi.argcnt = argcnt;

	       if (hp_type.descriptor.procwi.argcnt > 0) {
		  /* There exist args which need an arglist allocated */

		  hp_type.descriptor.procwi.arglist
		     = (HPTYSTR_ARG *)
			chkalloc(hp_type.descriptor.procwi.argcnt
				 * sizeof(HPTYSTR_ARG));
	       }
	       for ( cur_index = first_arg_index,
		       next_arg = hp_type.descriptor.procwi.arglist;
		     argcnt > 0;
		     cur_index += VALIDNUMAUX(cur_index, symbol.n_numaux) + 1 ) {
		  /* get a potential local symbol */
		  symbol = *CORESYMPTR(mod_ptr, first_index, cur_index);

		  if (IS_ARG(symbol) 
		      && cur_index != argptr_index
		      &&(!ignore_c_args  ||  symbol.n_sclass!=C_ARG)) {
		     if (symbol.n_numaux > 0)
			aux = *COREAUXPTR(mod_ptr, first_index, cur_index+1);
		     *next_arg++ = hl_type(&symbol, &aux, cur_index);
		     argcnt--; /* one more arg was processed */
		  }
               }
	    } else {
	       /* Function has no symbols; we don't know anything about
		* the args.
		*/
	       hp_type.descriptor.procwi.argcnt = HPUNKARGS;
	    }


         }
      
         /* fill in additional information for all function DTs:
	  * return type.
	  */
      
         hp_type.descriptor.procwi.rtype = last_handle;
         if (dt_index > 1)
	    error = hp_patchtype(&hp_type,  last_handle = next_handle++); 
	 else
	    error = hp_patchtype(&hp_type, TYPE_HANDLE(symindex));

	 CHKFREE(hp_type.descriptor.procwi.arglist);
         CHKFREE(hp_type.name);
         break; /* case DT_FCN */
      } /* switch */
      if (error < 0)
	 abort(); /* error from hp_*type call */
   
      /* One or more DT_FCN, DT_PTR or DT_ARY have been seen at this point */
      first_dt = FALSE;  /* DT_PTR, DT_ARY or DT_FCN was processed in swt*/
   } /* for */
}


/*
 * If the symbol in the module defined by
 * (curr_mod_ptr, first_mod_symindex, symindex) can be translated to
 * a 695 assembler static, do so and output the result.  In any case,
 * return the symbol table index for the symbol table entry beyond this
 * one.
 */
static int emit_b10sym( curr_mod_ptr, first_mod_symindex,
			symindex)

   SYMENT *curr_mod_ptr;
   long first_mod_symindex;
   long symindex;
{
   SYMENT symbol;
   AUXENT aux;
   HPSYM hp_symbol;

   symbol = *CORESYMPTR(curr_mod_ptr, first_mod_symindex, symindex);

   if (IS_695_ASMSTAT(symbol)) {
      hp_symbol.name = ldgetname(inldfile_ptr, &symbol);
      hp_symbol.type = HPBITY_UNK; /* default value; may chng */
      hp_symbol.asnval = symbol.n_value;
      hp_symbol.attribute.atnid = HPATN_ASMSTAT;
      hp_symbol.attribute.att.asmstat.globflag =
	 IS_695_GLOBAL(symbol);
      hp_symbol.attribute.att.asmstat.numelems = 1;
      /*---- Base type or a function */
      if (symbol.n_sclass == C_LABEL || IS_SPECIAL_PROCEDURE(symbol))
	  hp_symbol.type = HPBITY_J;
      else if (ISFCN(symbol.n_type)) 
	 hp_symbol.type = HPBITY_J;
      else if (ISPTR(symbol.n_type))
	 hp_symbol.type = HPBITY_M;
      else if (IS_NONSCALAR(symbol)) {
	 /*---- Structured type */
	 
	 aux = *COREAUXPTR(curr_mod_ptr, first_mod_symindex, symindex + 1);
	 hp_symbol.type = HPBITY_B;
	 hp_symbol.attribute.att.asmstat.numelems =
	    aux.x_sym.x_misc.x_lnsz.x_size;
      } else {
	 hp_symbol.type = hp_bity_of(BTYPE(symbol.n_type), UNRESTRICTED);
      }
      if (hp_putasym(&hp_symbol) < 0)
	 abort();
   }

   return symindex + 1 + VALIDNUMAUX(symindex, symbol.n_numaux);
   
}

static void init_ext_symbols(list)
   EXTLIST *list;
{
   list->head.next = &list->tail;
   list->head.prev = NULL;
   list->head.sym  = &list->vfirst;
   list->head.sym->n_value = 0; /* head's symbol value is <= any other */
   list->tail.next = NULL;
   list->tail.prev = &list->head;
   list->tail.sym  = &list->vlast;
   list->tail.sym->n_value = (LOGADR960)(-1);/*tail's symval is >= any other*/
   list->cur_ref = &list->head;
}

static void free_ext_symbols(list)
   EXTLIST *list;
{

   if (list->head.next != &list->tail) {
      free_ext_range(list->head.next, list->tail.prev);
   }
   init_ext_symbols(list);
}

/*
 * free_ext_range
 *
 * Unlink the EXTREF sublist between reflo and refhi inclusive, and deallocate
 * the EXTREF sublist.
 */
static void free_ext_range(reflo, refhi)
   EXTREF *reflo, *refhi;
{
   /* save refhi->next because it will hae been free'd at the end */
   /* of the loop when we need to dereference it */
   struct extref_tag * last = refhi->next;

   (reflo->prev->next = refhi->next) -> prev  =  reflo->prev;
   while (reflo != last) {
      EXTREF *cur = reflo;
      reflo = reflo->next;
      free(cur);
   }
}

/*
 * The symbol table entry at index sindex
 * is C_EXT storage class from the external part.  Place a reference
 * to the in-memory external symbol array in the
 * designated 'list'.
 *
 * Optimize the insertion for the situations where external symbols are
 * found in ascending or descending orders.
 */
static void insert_ext_symbol(sindex, list)
   long sindex;
   EXTLIST *list;
{
   EXTREF new;
   EXTREF *new_ref = (EXTREF*)chkalloc(sizeof(EXTREF));
   SYMENT *symbol = ext_mod_ptr + (sindex - ext_mod_index);
   LOGADR960 symbol_value = symbol->n_value;

   new.sym = symbol;
   if ((LOGADR960)list->tail.prev->sym->n_value <= symbol_value) {
       /* Optimization special case: symbol entry to be inserted
	* exceeds last element of the list; insert at end
	*/
      new.prev = (new.next = &list->tail) -> prev;
   } else {
      /* The place to enter the symbol must be searched for */
      new.next = (new.prev = &list->head) -> next;
      while ( (LOGADR960)new.next->sym->n_value < symbol_value ) {
	 new.next = (new.prev = new.next) -> next;
      }
   }
   /* assert: The references within 'new' refer correctly to the list */
   new.prev->next = new_ref;
   new.next->prev = new_ref;
   *new_ref = new;
   /* assert: The references after and before the new element refer
    * to the new element 
    */
}

/*
 * first_ext_symbol delivers the first external symbol from the auxiliary
 * EXTLIST 'list', and either returns its symbol table index, or an index
 * past the end of the symbol table if the 'list' is empty.
 *
 * Globals referenced:  ext_mod_index, ext_mod_ptr, sentinel_symindex.
 */
static long first_ext_symbol(list, symbol)
   EXTLIST *list;
   SYMENT *symbol;
{

   if (list==NULL  ||  list->head.next==(&list->tail))
      /* empty list */
      return sentinel_symindex;
   else {
      SYMENT *cursymptr = (list->cur_ref = list->head.next)->sym;

      *symbol = *cursymptr; /* deliver the symbol */
      
      return ext_mod_index + (cursymptr-ext_mod_ptr); 
         /* deliver the syms index*/
   }
}

/*
 * Deliver the next symbol from the auxiliary list,
 * and its symbol table index, or an index beyond
 * the end of the table if such does not exist.  The external symbol
 * table segment is not accessed directly, but through the auxiliary
 * structure 'list'.
 *
 * Globals referenced:  ext_mod_index, ext_mod_ptr, sentinel_symindex.
 */
static long next_ext_symbol(list, symbol)
   EXTLIST *list;
   SYMENT *symbol;
{     

   if (list->cur_ref == &list->tail ||
       (list->cur_ref = list->cur_ref->next) == &list->tail) { 
	  /* empty list, or already read all */
      return sentinel_symindex;

   } else {
      SYMENT *cursymptr = list->cur_ref->sym;

      *symbol = *cursymptr; /* deliver the symbol */
      return ext_mod_index + (cursymptr-ext_mod_ptr); 
         /* deliver the syms index */
   }
}

/*
 * find_ext_range
 *
 * Given a list of EXTREFs and and the pair (val1, val2), return
 * in *pr1 and *pr2 the EXTREF sublist whose members satisfy:
 *    (val1 <= value_of_extref <= val2).
 */
static void find_ext_range(list, val1, val2, pr1, pr2)
   EXTLIST *list;	 /* list to search */
   LOGADR960 val1, val2; /* [val1..val2] is the numerical range of values */
   EXTREF **pr1, **pr2; /* outputs: pointers to the EXTREFS in the range. */
{
   EXTREF *cur_ref = list->head.next;
   EXTREF *tail = &list->tail;
   EXTREF *r2 = NULL;
   *pr1 = NULL; /* base assumption: no extrefs found. */

   while (cur_ref != tail &&
	  (LOGADR960)cur_ref->sym->n_value < (LOGADR960)val1) {
      cur_ref = cur_ref->next;
   }
   /* cur_ref points to a reference of value >= val1 */
   if (cur_ref != tail &&
       (LOGADR960)cur_ref->sym->n_value <= val2) {
      *pr1 = cur_ref;

      while (cur_ref != tail &&
	     (LOGADR960)cur_ref->sym->n_value <= val2) {
         r2 = cur_ref;
	 /* (*pr1, r2) describe the inclusive range */
         cur_ref = cur_ref->next;
      } /*while*/
   } /*if*/
   *pr2 = r2; /* deliver the end of the range */
}

static void read_symbol_with_index(symindex, symbol_ptr)
   long    symindex;
   SYMENT* symbol_ptr;
{
   if (ldtbread(inldfile_ptr, symindex, symbol_ptr) != SUCCESS) {
      error_out(error_prefix, RD_SYMTB, NO_SUB);
      abort();
   }
}

/*
 * ldget_f_name
 *
 * Given a pointer to an aux entry for a ".file" symbol, return the
 * name of the file.  We assume that sentinel_symindex must be > 0
 * since the aux ptr must be pointing at an aux entry from the symbol table.
 * Any stdio problems in accessing the string table will be caught with
 * ferror().
 */
static char *ldget_f_name(ldfile, aux_ptr)
   LDFILE *ldfile;
   AUXENT *aux_ptr;
{

#if defined(MSDOS)
   clearerr(IOPTR(ldfile)); /* clear spurious DOSX errors */
#endif

   if (aux_ptr->x_file.x_n.x_zeroes != 0) {
      return aux_ptr->x_file.x_fname;
   } else {

      static char *buf = NULL;

      int bufs = 0;
      long fstr;
      int ch;
      
      ldtbseek(ldfile);
      /* stream positioned at begin of symbol table */
      fseek(IOPTR(ldfile), sentinel_symindex*sizeof(SYMENT), 1 /*current*/);
      /* stream positioned at begin of string table */
      fseek(IOPTR(ldfile), aux_ptr->x_file.x_n.x_offset, 1 /*current*/);
      /* stream positioned at begin of string */
      fstr = ftell(IOPTR(ldfile));
      if (buf!=NULL) {
	 /* this time-wasteful treatment of an earlier buffer is forgiven
	  * by the rarity of getting into this algorithm at all.
          */
         free(buf);
      }
      for ( bufs = 0; EOF!=(ch=getc(IOPTR(ldfile)));) {
	 bufs++;
	 if (ch==(int)'\0')
	    break;
      }

      buf = chkalloc(bufs);
      fseek(IOPTR(ldfile), -bufs, 1 /*current*/);
      /* repositioned at beginning of string */
      fread(buf, bufs, 1, IOPTR(ldfile));

      if (ferror(IOPTR(ldfile))) {
	 error_out(error_prefix, RD_STRTB, NO_SUB, infile_name);
	 abort();
      } else
         return buf;
   }
}

/*
 * bread_alloc_mod
 *
 * This function's objective is exactly the same as read_alloc_mod
 * but the caller guarantees that first_symindex..last_symindex are
 * the valid index-bounds of the module.
 */
static SYMENT* bread_alloc_mod(first_symindex, last_symindex)
   long    first_symindex;
   long    last_symindex;
{
   long     sym_cnt;  /* # of symbols in the segment to allocate */
   SYMENT*  ret_val;  /* pointer to memory area allocated */
   SYMENT   symbol;


   sym_cnt = last_symindex - first_symindex + 1;
   ret_val = (SYMENT*) chkalloc(SYMESZ * sym_cnt);
   if (fseek(IOPTR(inldfile_ptr), 
             HEADER(inldfile_ptr).f_symptr + first_symindex * SYMESZ,  0)
       == 0)
   {
      if (fread(ret_val, SYMESZ, sym_cnt, IOPTR(inldfile_ptr)) == sym_cnt)
         /* The file pointer has moved beyond what was read */
         return ret_val;
   }
   error_out(error_prefix, ER_FREAD, NO_SUB, infile_name);
   abort();
}

/*
 * read_alloc_mod
 *
 *    Reads a segment of symbol table entries into memory and returns
 *    a pointer to the memory; specifically the extent of a source-module's
 *    symbols, or the extent of the external symbols.
 *
 *    On entry, the first index of the module is known, but the extent
 *    is unknown.  On exit, the extent read was determined from the
 *    aux entry of initial .file symbol, or else the whole rest of the
 *    symbol table was read.
 *
 *    Missing .file symbols (which result from omitted .file directives),

 *    FIXME: reference to ancient .bss2 section.

 *    or extra section information (.text,.data,.bss,.bss2)
 *    caused by incremental linking which are
 *    beyond the first-indexed symbol will cause this routine to read more
 *    than the initial module into the memory area.
 *    The caller must detect and deal with this.
 *
 *    Returns the last-index of the segment read to the caller.
 */
static SYMENT* read_alloc_mod(sentinel_index, first_symindex, 
                       last_symindex)
   long    sentinel_index;
   long    first_symindex;
   long*   last_symindex;
{
   long     sym_cnt;  /* # of symbols in the segment to allocate */
   SYMENT*  ret_val;  /* pointer to memory area allocated */
   SYMENT   symbol;

   read_symbol_with_index(first_symindex, &symbol);
      /* symbol is the symbol at first_symindex */
   if (IS_FILE(symbol))
      *last_symindex = (LOGADR960)symbol.n_value - 1;
      /* Tell caller what last symbol index of the file read was */
   else
      *last_symindex = sentinel_index - 1;
      /* Tell caller where the end of the symbol table is */

   sym_cnt = (*last_symindex - first_symindex + 1);
   ret_val = (SYMENT*) chkalloc(SYMESZ * sym_cnt);
   if (fseek(IOPTR(inldfile_ptr), 
             HEADER(inldfile_ptr).f_symptr + first_symindex * SYMESZ,  0)
       == 0)
   {
      if (fread(ret_val, SYMESZ, sym_cnt, IOPTR(inldfile_ptr)) == sym_cnt)
         /* The file pointer has moved beyond what was read */
         return ret_val;
   }
   error_out(error_prefix, ER_FREAD, NO_SUB, infile_name);
   abort();
}

static bool is_bf(symbol_ptr)
   SYMENT* symbol_ptr;
{
   register char*          symbol_name;

   symbol_name = ldgetname(inldfile_ptr, symbol_ptr);
   return (symbol_ptr->n_sclass == C_FCN && !strcmp(symbol_name, ".bf"));
}

static bool is_ef(symbol_ptr)
   SYMENT* symbol_ptr;
{
   register char*          symbol_name;

   symbol_name = ldgetname(inldfile_ptr, symbol_ptr);
   return (symbol_ptr->n_sclass == C_FCN && !strcmp(symbol_name, ".ef"));
}

static bool is_bb(symbol_ptr)
   SYMENT* symbol_ptr;
{
   register char*          symbol_name;

   symbol_name = ldgetname(inldfile_ptr, symbol_ptr);
   return (symbol_ptr->n_sclass == C_BLOCK && !strcmp(symbol_name, ".bb"));
}

static bool is_eb(symbol_ptr)
   SYMENT* symbol_ptr;
{
   register char*          symbol_name;

   symbol_name = ldgetname(inldfile_ptr, symbol_ptr);
   return (symbol_ptr->n_sclass == C_BLOCK && !strcmp(symbol_name, ".eb"));
}

/* 
 * is_section_info
 *    Is it (symbol) a COFF segment info symbol.
 */
static bool is_section_info(symbol_ptr)
   SYMENT* symbol_ptr;
{
   register char *symbol_name;

   /* for 4.0 & General Section Model this code is left as-is,
    * cvt960 seems to work for all GSM cases we have tryed to 
    * date.  I thought about removing the IS_COFF_SEGMENT_NAME
    * check, but discussions showed that 1) for whatever reason(s)
    * it works as is, and 2) if IS_COFF_SEGMENT_NAME is removed,
    * then is_section_info() may return false-positive on a
    * symbol_ptr and that "could" be a BAD thing.
    */
   /* For 4.0, we have now added a new flag definition for the */
   /* n_flags filed to indicate section symbols.  This code remains */
   /* to handle pre-4.0 object modules */

   return (((symbol_ptr->n_flags & F_SECT_SYM) != 0) 
	   || (symbol_ptr->n_type == T_NULL 
	   && symbol_ptr->n_sclass == C_STAT
	   && symbol_ptr->n_scnum > 0
	   && (symbol_name = ldgetname(inldfile_ptr, symbol_ptr),
	       IS_COFF_SEGMENT_NAME(symbol_name))));
}

/*
 * hp_bity_of 
 *
 * Translate a COFF base type into a corresponding 695 type from 
 * HP/MRI 695 V4.0 Table A-2.
 *
 * If the translation is being done for the purposes of producing
 * the public part, there is a restriction in the translation range;
 * in this case, restricted == TRUE.
 */
static char hp_bity_of(symbol_btype, restricted)
   unsigned long symbol_btype;
   bool restricted;
{
   switch (symbol_btype) {
   case T_CHAR:
      return HPBITY_B;  /* <<<<<<<<<< */

   case T_SHORT:
      if (restricted)
         return HPBITY_I;
      else
	 return HPBITY_H;  /* <<<<<<<<<< */

   case T_INT:
   case T_LONG:
      if (restricted)
	 return HPBITY_M;  /* <<<<<<<<<< */
      else
	 return HPBITY_L;

   case T_FLOAT:
      return HPBITY_F;  /* <<<<<<<<<< */

   case T_DOUBLE:
      return HPBITY_D;  /* <<<<<<<<<< */

   case T_UCHAR:
      if (restricted)
	 return HPBITY_B;  /* <<<<<<<<<< */
      else
	 return HPBITY_C;

   case T_USHORT:
      return HPBITY_I;  /* <<<<<<<<<< */

   case T_UINT:
   case T_ULONG:
      return HPBITY_M;  /* <<<<<<<<<< */

   case T_LNGDBL:
      return HPBITY_K;  /* <<<<<<<<<< */

   case T_VOID:
      if (restricted)
	 return HPBITY_UNK;
      else
	 return HPBITY_V;

   case T_NULL:
      /* T_NULL can occur in the COFF symbol table; it is a good
       * idea to translate it explicitly as unknown.
       */
      /* fall-through */

   case T_STRUCT:
   case T_UNION:
   case T_ENUM:
   case T_MOE:
   default:
      /* VOID..MOE or others should not get here,
       * but it would be a shame to
       * abort the whole translation if they ever did.
       */
      return HPBITY_UNK;

   } /* switch */
}

/*
 * tool_version
 *
 * Extract a string of the form X99.99.999 or V99.99.999 from the string,
 * ignoring leading whitespace.
 */
static char *tool_version(string)
   char *string;
{
   static char version[11];
   int cur = 0;

   while (*string  &&  *string != 'X'  &&  *string == 'V')
      string++;

   if (*string == 'X'  ||  *string == 'V') {
      version[cur++] = *string++;
      while (cur < 10  &&  (isdigit(*string)  ||  *string == '.')) {
	 version[cur++] = *string++;
      }
   }
   version[cur] = '\0';
   return version;

}

extern int const_time_flag;

static int setflags(argc, argv)
   int argc;
   char** argv;
   /*
    *  Purpose:
    *    Set option flags.
    */
{
   extern char* optarg;
   extern int optind;
   int ch, error_flag;
   char *outfile_tmp = NULL;
    struct tabentry { char *flag; int arch; };
    static struct tabentry arch_tab[] = {
    	"KA", F_I960KA,
    	"KB", F_I960KB,
    	"SA", F_I960KA,
    	"SB", F_I960KB,
    	"CA", F_I960CA,
    	"CF", F_I960CA,
    	"JA", F_I960JX,
    	"JF", F_I960JX,
    	"JD", F_I960JX,
    	"JL", F_I960JX,
    	"RP", F_I960JX,
    	"HA", F_I960HX,
    	"HD", F_I960HX,
    	"HT", F_I960HX,
    	NULL, 0
    };
    struct tabentry *tp;

    architecture = NULL;
   check_v960(argc, argv);	/*Never returns if -v960 in command line */
   error_flag = OFF;
   infile_name = defaultinfile_name;
   while ((ch = getopt(argc, argv,options)) != EOF) {
      switch ((char)ch) {
         case 'A':
	    for (tp = arch_tab; tp->flag != NULL; tp++) {
	    	if (!strcmp(optarg, tp->flag)){
	    		break;
	    	}
	    }

	    if (tp->flag == NULL) {
	    	return (FAIL);
	    } else {
	    	architecture = tp->arch;
	    }
	    break;

	 case 'a':
	    amc_mri = TRUE;
	    break;

         case 'c':
	    column_zero = TRUE;
	    break;

	 case 'w':
            ignorewarns = ON;
            break;

	 case 's':
 	    ignoresymbols_flag = ON;
	    break;

         case 'h':
            put_cvt_help();
            exit(0);
         
	 case 'i':
            infile_name = optarg;
            break;

	 case 'o':
	    outfile_tmp = optarg;
	    break;

	 case 'V':
	    gnu960_put_version();
	    break;

	 case 'z':
	    const_time_flag = ON;
	    break;

         case '?':
	 default:
	    error_flag = ON;
      }
   }

   if (error_flag == ON) 
      return (FAIL);
   else {
      if (outfile_tmp) {
	 /* The user supplied an explicit file name */
         outfile_name = outfile_tmp;
      } else {
         char *dotptr = NULL;
         char *infile_tmp = file_name(infile_name);
         char *moved = outfile_name = chkalloc(strlen(infile_tmp)+1+2);
      
         /* Enough storage is allocated for an output file name as long
          * as the input file name, + ".x".
          */
         for (;;) {
            if (*moved = *infile_tmp) {
               if (*moved == '.')
                  dotptr = moved;
               infile_tmp++;
               moved++;
            } else {
	       /* the '\0' was moved */
               break;
            }
         } 
	 dotptr = (dotptr? dotptr: moved);
         /* dotptr points at the last '.' moved, or else to the final '\0' */
	 strcpy(dotptr, ".x");
      }
      /* outfile_name points to the output file name */
      return (OK);
   }
}

static char* get_command_line(argc, argv)
   int    argc;
   char** argv;
   /*
    *  Purpose
    *    Builds the command line image and returns a pointer to it.
    */
{
   register int i;
   register int len = 0;
   register int arg_len;
   register char* image;
   register char* curr_ptr;

   for (i = 0; i < argc; i++) {
      len += strlen(argv[i]);
   }
   len += argc;  /* ' ' between arguments and terminating null char */
   image = curr_ptr = calloc(len, 1);
   for (i = 0; i < argc; i++) {
      arg_len = strlen(argv[i]);
      memcpy(curr_ptr, argv[i], arg_len);
      curr_ptr += arg_len;
      *curr_ptr++ = ' ';
   }
   *--curr_ptr = '\0';
   return (image);
}
/*
 * convert_to_695
 *  Purpose:
 *    Opens "infile_name" (COFF file), "outfile_name" (will be in 695) 
 *    and translates "infile_name" to 695 format ("outfile_name").
 *  Parameters:
 *    argc, argv needed to build the image of the command line.
 */
static void convert_to_695(argc, argv)
   int    argc;
   char** argv;
{
   register unsigned short no_scns, scn;
   long first_file_index; /* index to the first .file symbol; iff 
			   * sentinel_symindex > 0.  Would always be 0 if
			   * there were not missing .file dirs in '.s' code.
			   */
   LOGADR960 saved_begin_block;

   struct file_sec_info_type {
      unsigned short sec_num;   /* section number of module-section */
      LOGADR960      sec_value; /* base of module-section */
      unsigned long  sec_len;   /* size of module-section */
      EXTREF*        first_xref; /* first external within module section */
      EXTREF*        last_xref;  /* last external within module section */
   } file_sec_info[MAX_SCNS];
   short file_sec_info_end; /* index beyond end of file_sec_info[] */
      /* file_sec_info[] is bounded by index file_sec_info_end, and is used
       * to keep track of module-section information extracted from passes
       * which look at section symbols (i.e. is_section_info() == TRUE).
       */
   EXTREF *cur_ref; /* current global within module section */
   SOURCE_MOD *source_mod_first = NULL;
   SOURCE_MOD *source_mod_last = NULL;
   SOURCE_MOD *source_mod_cur = NULL;

   struct tool_stamp {
      unsigned long id; /* HP/MRI 695 tool id */
      long utime;       /* seconds since 1970 */
      char vers[11];    /* "X99.99.999\0" */
   } comp_tool, asm_tool, conv_tool;

   bool seen_348 = FALSE;

   if ((inldfile_ptr = ldopen(infile_name, NULL)) == NULL) {
      error_out(error_prefix, NOT_OPEN, NO_SUB, infile_name);
      abort();
   }
   infile_ptr = IOPTR(inldfile_ptr);

   /*----  Check for executable COFF file */
   if ( (!(ISCOFF((HEADER(inldfile_ptr)).f_magic)))
       || (!((HEADER(inldfile_ptr)).f_flags & F_EXEC))
       || (TYPE(inldfile_ptr) == ARTYPE)
      )
   {
      error_out(error_prefix, NOT_COFF, NO_SUB, infile_name);
      /* UPDATE: Archives error-exit here, and the error message
       * we produce could be more clear in that case.
       */
      abort();
   }
   
   /* Assert: inldfile_ptr is an executable and not an archive. */

   if (ignoresymbols_flag == OFF) {
      sentinel_symindex = HEADER(inldfile_ptr).f_nsyms;
         /* 1-beyond the last valid symbol table index */
   } else { /* ignoresymbols_flag == ON */
      sentinel_symindex = 0;
         /* pretend there are no symbols */
   }

   /* Read in the string table to support fast ldgetname() functionality. */

   if (HEADER(inldfile_ptr).f_nsyms) {
       if (FSEEK(inldfile_ptr,STROFFSET(inldfile_ptr),BEGINNING) != OKFSEEK)
	       abort();
       else {
	   unsigned long string_table_size = 0;

	   if (FREAD(&string_table_size,4,1,inldfile_ptr) != 1)
		   abort();
	   if (string_table_size) {
	       __string_table__ = chkalloc(string_table_size-3);
	       if (FREAD(__string_table__,string_table_size-4,1,inldfile_ptr) != 1)
		       abort();
	       __string_table__[string_table_size-4] = 0;
	   }
	   else
		   __string_table__ = "";
       }
   }
   else
	   __string_table__ = "";

   /*---- Collect required information for call to hp_create */
   {
      extern char _version[];
      HP695_MODDESCR mod_descr;

      argv[0] = const_time_flag ? "<cvt960>" : argv[0];
      mod_descr.client = argv[0];
      mod_descr.toolid = HPTOOL_CVT960;
      strncpy(conv_tool.vers, _version,10);
      conv_tool.vers[10] = 0;
      conv_tool.id = HPTOOL_CVT960;
      create_hpvers(conv_tool.vers, &mod_descr.version);
      mod_descr.cpu = (HEADER(inldfile_ptr).f_flags & F_I960TYPE);
      mod_descr.lmodname = infile_name;
      mod_descr.outputname = outfile_name;
      mod_descr.timdat = HEADER(inldfile_ptr).f_timdat;
      mod_descr.hostenv = HPHOST_695WRTR;
      mod_descr.comline = get_command_line(argc, argv);

      strcpy(comment_buf, CVTNAME);
      strcat(comment_buf, " ");
      strcat(comment_buf, conv_tool.vers);
#if defined(CTOOLS)
      sprintf(comment_buf + strlen(comment_buf), 
	      "\n%s\n%s", ie_version, hp_version);
#endif
      mod_descr.comment = comment_buf;

      /* 'cvt960_abort' is installed as a handler immediately before opening the
       * output file.  This supports the deletion of the output file
       * if there is an interrupt.
       */
#if ( ! defined( __GCC960 ) ) && ! ( defined( DOS ) && defined( __HIGHC__ ) )

#if !defined(CBLD) && !defined(WIN95)
      if (signal(SIGHUP,SIG_IGN) == SIG_DFL)
	 signal(SIGHUP,cvt960_abort);
#endif
      if (signal(SIGINT,SIG_IGN) == SIG_DFL)
	 signal(SIGINT,cvt960_abort);
      if (signal(SIGTERM,SIG_IGN) == SIG_DFL)
	 signal(SIGTERM,cvt960_abort);
#endif

      if (hp_create(&mod_descr) < 0) {
         abort();
      }
   }


   no_scns = HEADER(inldfile_ptr).f_nscns;
   if (no_scns > MAX_SCNS) {
      error_out(error_prefix, TOO_MANY_SCNS, NO_SUB, MAX_SCNS);
      abort();
   }
   /*---- Write section header information */
   {
      SCNHDR secthead;

      for (scn = 1; scn <= no_scns; scn++) {
          int section_type;
          int section_size;
	  long linkatt;
	  char alinkatt[16];
	  char *palinkatt = NULL;
	  char section_name[9];

         /*---- More section information to read ? */
         if (ldshread(inldfile_ptr, scn, &secthead) == FAILURE)
            break;

	 switch (linkatt = (secthead.s_flags & SHF_LINKATT)) {
	    case STYP_NOLOAD:
	    case STYP_REG:
	       break;

	    case STYP_DSECT:
               if (!ignorewarns)
	          warn_out(error_prefix, SYMCONFLICT, NO_SUB, scn, "DSECT");
	       break;

	    case STYP_COPY:
               if (!ignorewarns)
	          warn_out(error_prefix, DATACONFLICT, NO_SUB, scn);
	       break;

	    case STYP_GROUP:
	       strcpy(alinkatt, "GROUP");
	       palinkatt = alinkatt;
	       break;

	    case STYP_PAD:
	       strcpy(alinkatt, "PAD");
	       palinkatt = alinkatt;
	       break;

	    default:
	       sprintf(alinkatt, "%#x", linkatt);
	       palinkatt = alinkatt;
	       break;
	 }
	 if (palinkatt != NULL ) {
            error_out(error_prefix, UNEXPECTED_SECTYPE, NO_SUB, 
		      scn, palinkatt);
	    abort();
	 }
         switch (secthead.s_flags & SHF_CONTENT) {
            case STYP_TEXT:
               section_type = HPABST_CODE;
	       break;
            case STYP_DATA:
            case STYP_BSS:
            default:
               section_type = HPABST_RWDATA;
	       break;
         }
         section_size = secthead.s_size;
	 /* An 8 character section name is not a nul terminated string */
	 /* Make sure we have a nul terminated string */
	 strncpy(section_name, secthead.s_name, 8);
	 section_name[8] = 0;
         if (0>hp_creabsect(section_name, scn, section_type, section_size,
                      secthead.s_paddr))
	    abort();
         sec_info[scn].sec_flags = secthead.s_flags;
         sec_info[scn].sec_name  = strcpy(chkalloc(strlen(secthead.s_name)+1),
                                        secthead.s_name);
         sec_info[scn].sec_size  = section_size;
         sec_info[scn].sec_paddr = secthead.s_paddr;
	 init_ext_symbols(&sec_info[scn].globlist);
      } /* for */
   }

   if (sentinel_symindex > 0  &&  ldtbseek(inldfile_ptr) == SUCCESS) {
      /* We are at the 0th index of the symbol table */
      long file_search_index = 0; /* begin looking at index 0 */
      SYMENT file_search_symbol;
 
      while ((file_search_index < sentinel_symindex)) {
	 ldtbread(inldfile_ptr, file_search_index, &file_search_symbol);
	 if (IS_FILE(file_search_symbol))
	    break;
	 else
	    file_search_index += VALIDNUMAUX(file_search_index, 
					file_search_symbol.n_numaux) + 1;
      }

      if (file_search_index < sentinel_symindex)
	 first_file_index = file_search_index;
      else {
 	 sentinel_symindex = 0; /* mark the symbol table as non-existent */
         if (!ignorewarns)
	    warn_out(error_prefix, NO_FILE_SYMS, NO_SUB);
	 /* warn the user of same */
      }

   }

   if (sentinel_symindex > 0  &&  ldtbseek(inldfile_ptr) == SUCCESS) {
      long first_mod_symindex, last_mod_symindex;
      SYMENT* mod_ptr;

      /* Since the public part is to be produced, check for PIX flags, and
       * produce a warning if found.
       * We currently do not know what to do in order to translate
       * such information to 695.
       */
      if ((HEADER(inldfile_ptr).f_flags) & (F_PIC|F_PID)) {
         if (!ignorewarns && !had_pix_error) {
	    warn_out(error_prefix, PIX_NOTRANS, NO_SUB);
	    /* only output 1 warning, not one for every occurance */
	    /* remember, most every library function is PIX */
	    had_pix_error = TRUE;
	 }
      }

   /*---- Write the public part; also do the following on-the-fly:
    * 1. Create lists of global bss and global data for future traversals.
    * 2. Create a list of plausible source modules to get around
    *   the fact that the .file linked list may be misleading.  Note
    *   that execution does not come here if there are no .file symbols.
    */


      for (first_mod_symindex = first_file_index ;
	   first_mod_symindex < sentinel_symindex; 
           first_mod_symindex = last_mod_symindex + 1)
      {
         long          symindex;
         SYMENT        symbol;
         HPXSYM        symbol_695;
         int           ext_pass = FALSE;
	 long          true_last_symindex; /* = last_mod_symindex except
					    * for missing .file symbols.
					    */
	 /* FIXME: Sections can be named virtually anything in coff.
	    not only .text, .data, .bss or .bss2. */
	 /* keep track of .data, .text, .bss and .bss2 symbols to track missing
	  * .file symbol.
	  */
	 int t_section=0, d_section=0, b_section=0, b2_section=0;
	 long last_init_modsect = 0;

         mod_ptr = read_alloc_mod(sentinel_symindex, 
                                  first_mod_symindex, &last_mod_symindex);
         true_last_symindex = last_mod_symindex;

         for (symindex = first_mod_symindex; symindex <= last_mod_symindex; 
              ++symindex) 
         {
	    /* The index is within the range described by the .file symbol,
	     * and we have not yet encountered duplicate file_sec_info.
	     */
	    char *symbol_name;

            symbol = *CORESYMPTR(mod_ptr, first_mod_symindex, symindex);
	    symbol_name = ldgetname(inldfile_ptr, &symbol);
      /* we will leave this in for R4.0 and later so that
       * we can detect "incorrect" COFF files from earlier
       * releases.
       */
	    if (is_section_info(&symbol)) {
	       /* We examine section info to detect premature end of
		* module.
		*/
	       unsigned short i;

	    /* symbol_name will point to ".text", ".data", ".bss" or ".bss2".
	       FIXME: reference to ancient bss2 section.
	     */
	       if (( symbol_name[1] == 't'  &&  t_section++ == 0)
		   ||(symbol_name[1] == 'd' &&  d_section++ == 0)
		   ||(symbol_name[1] == 'b' && 
                       (((strlen(symbol_name+2)==2)  &&  b_section++ == 0)
			||
			((strlen(symbol_name+2)==3)  &&  b2_section++ == 0)))){
		  /* the symbol is section info for a new section */
		  last_init_modsect = symindex +
		     VALIDNUMAUX(symindex, symbol.n_numaux);
		     /* last_init_modsect is the largest index 
		      * within an unrepeated section symbol.
		      */
	       } else {
		  /* Discovery of repeated section_info.  We should
		   * consider the last original section info to be the
		   * true end of the module rather than last_mod_symindex.
		   */
		  true_last_symindex = last_init_modsect;
		  break; /* for each index in the module */
	       }
	    } else if (symindex == first_mod_symindex
		       &&  ! IS_FILE(symbol) ) {
	       /* We have a symbol in the .file chain which is not itself
		* a .file; this indicates the global part.
		*/
               ext_mod_ptr = mod_ptr;
               ext_mod_index = symindex;
               ext_pass = TRUE;
	    }

            if (IS_695_PUBLIC(symbol)) {
               if (ext_pass && IS_SEC_GLOBAL(symbol)) {
                  /* Assert: symbol is an external variable from a section
                   * > 0; that is, a defined var in a memory section.
                   */

		  insert_ext_symbol(symindex, 
				    &sec_info[symbol.n_scnum].globlist);
               }

               symbol_695.name     = symbol_name;
               symbol_695.bity     = HPBITY_UNK; /* default value; may chng */
               symbol_695.value    = symbol.n_value;
               symbol_695.numelems = 1;

               /*---- Base type or a function */
	       if (ISFCN(symbol.n_type) || IS_SPECIAL_PROCEDURE(symbol))
                  /*                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                   * The kludge above is necessary because sometimes
                   * leaf procedures and system procedures are mistakenly
                   * given null type.
                   */
                  symbol_695.bity = HPBITY_J;
               else if (ISPTR(symbol.n_type))
                  symbol_695.bity = HPBITY_M;
               else if (IS_NONSCALAR(symbol)) {
                  /*---- Structured type */
                  AUXENT        aux;

		  aux = *COREAUXPTR(mod_ptr, first_mod_symindex, symindex+1);
                  symbol_695.bity = HPBITY_B;
                  symbol_695.numelems = aux.x_sym.x_misc.x_lnsz.x_size;
               } else if (symbol.n_type == T_NULL  &&  
			  symbol.n_scnum > 0 /* in memory section */ &&
			  (sec_info[symbol.n_scnum].sec_flags & STYP_TEXT)){
		  /*
		   * A global symbol with null type which is in text could
		   * be considered BITY unknown, but we can do better by
		   * calling it a code address.
		   */
		  symbol_695.bity = HPBITY_J;
	       } else {
                  symbol_695.bity =
		     hp_bity_of(BTYPE(symbol.n_type), RESTRICTED);
               }
               if (hp_putxsym(&symbol_695) < 0) {
                  abort();
               }
	       if (IS_SPECIAL_PROCEDURE(symbol)) {
		  AUXENT *aux2 
		     = COREAUXPTR(mod_ptr, first_mod_symindex, symindex+2);
		  long info2 = (symbol.n_sclass == C_SCALL ?
		     aux2->x_sc.x_stindx:
		     (aux2->x_bal.x_balntry - symbol.n_value));

		  put_procmark(HPATN_VMISC, symbol.n_sclass, info2);
	       }
            }
	    /* skip auxiliary entries */
            symindex += VALIDNUMAUX(symindex, symbol.n_numaux);
	    
         }

         /* 
	  * first_mod_symindex..true_last_symindex is the index-range
	  * of the module processed.
	  */
         if (!ext_pass) {
            CHKFREE(mod_ptr); /* the symbols of the current module 
			    * are discarded.
			    */
	    if (source_mod_first == NULL) {
	       source_mod_first = source_mod_last = 
		  (SOURCE_MOD *)chkalloc(sizeof(SOURCE_MOD));
	       /* First source module in the list */
            } else {
	       source_mod_last = source_mod_last->next =
		  (SOURCE_MOD *)chkalloc(sizeof(SOURCE_MOD));
	       /* Next source module in the list */
	    }
	    /* Remember the index-bounds of the module we processed.
	     * Note that it begins with a .file, and terminates with
	     * either the last index of the last original section symbol,
	     * or the index before the next entry in the .file chain.
	     */
	    source_mod_last->first_index = first_mod_symindex;
	    source_mod_last->last_index = true_last_symindex;
	    source_mod_last->next = NULL;
#ifdef DEBUG3
         printf("Source module in range (%d .. %d).\n", 
                first_mod_symindex, 
                true_last_symindex);
#endif
	 } 
      }
   }

   init_n = next_n; /* set first index for debug NN indecies */

   if (sentinel_symindex > 0)  {
      /*----  Write debug section information  */

      EXTREF*       cur_xref;
      SOURCE_MOD**  cur_mod;
      long          first_mod_symindex, aft_file_symindex, last_mod_symindex,
		    symindex;
      SYMENT*       curr_mod_ptr;
      SYMENT        symbol;
      AUXENT        aux;
      bool          llsyms;
      char          source_buf[MAXAUTO_SPATH]; /*moderate sized buffer for
						* source path.
						*/
      char*         source_path=source_buf;    /* full name of source module
						* from .file 
						*/
      
      /*----  For each source module */
      for (source_mod_cur = source_mod_first; 
	   source_mod_cur != NULL;
           source_mod_cur = source_mod_cur->next) {

         bool inside_HLmodule;
         unsigned short sec_num;
	 bool first_modline;

	 first_mod_symindex = source_mod_cur->first_index;
	 last_mod_symindex = source_mod_cur->last_index;
	 /* first_mod_symindex and last_mod_symindex are the boundary
	  * indices of the module.
	  */

	 curr_mod_ptr = bread_alloc_mod(first_mod_symindex, last_mod_symindex);
	 /* The module's symbols are in memory */

         symbol = *CORESYMPTR(curr_mod_ptr, first_mod_symindex, 
			   first_mod_symindex);
	 aft_file_symindex = first_mod_symindex +
	    VALIDNUMAUX(first_mod_symindex, symbol.n_numaux) + 1;
         aux = *COREAUXPTR(curr_mod_ptr, first_mod_symindex, 
			    first_mod_symindex + 1);
	 /* symbol and aux are defined to be the first .file entry */

	 /* Begin initializing tool id information */
	 comp_tool.id = asm_tool.id = HPTOOL_UNK;
	 comp_tool.vers[0] = asm_tool.vers[0] = '\0';

	 /* end initializing tool id information */

	 {
	    /* Delete the following standard suffixes to form
	     * an XRAY-compatible module name: .s, .as, .c, .i
	     */
	    /* .c and .i are considered high level modules, others not */

	    char *mname = ldget_f_name(inldfile_ptr, &aux);
	    char *suff = (char *) rindex(mname, '.');
	    int szmname = strlen(mname)+1;
#ifdef DEBUG1
	    char fname[128];
#endif
	    if (strcmp (mname, "<stdin>") == 0) {
	      strcpy(mname, "unknown");
	    }
#ifdef DEBUG1
	    strncpy(fname,mname,127);
#endif

	    inside_HLmodule = FALSE;
	   
	    if ( szmname > MAXAUTO_SPATH ) {
	       source_path = chkalloc(szmname);
	    } else {
	       source_path = source_buf;
	    }
	    /* assert: source_path points either to sufficient auto storage
	     * or to dynamic.
	     */
	    strcpy(source_path, mname);
	       
	    if (suff) {
	       suff++; /* beyond '.' */

	       /* do not trim suffix if '-a' (amc) command line switch
		* was specified
		*/
	       if (0==strcmp(suff, "i")  ||  0==strcmp(suff, "c")) {
		  inside_HLmodule = TRUE;
#if 0
		  if(amc_mri == FALSE) {
		    *(suff-1) = '\0';
		  }
	       } else if (0==strcmp(suff, "s")  ||  0==strcmp(suff, "as")) {
		  if(amc_mri == FALSE) {
		    *(suff-1) = '\0';
		  }
#endif
	       }
            }
#ifdef DEBUG1
	    fprintf(stdout, "----  Coff File %s; Module %s\n",fname, mname);
#endif
            if (0>hp_openmod(mname, 0))
	       abort();
         }


#ifdef DEBUG
         fprintf(stdout, "----  Module %s\n", aux.x_file.x_fname);
#endif
         /*----  Collect module section information  */
         /* and apply a heuristic method to determine whether the module
          * was compiled with -g
          */

	 file_sec_info_end = -1; /*prior to beginning of file_sec_info array */
         for (symindex = aft_file_symindex;
              symindex <= last_mod_symindex; 
              symindex += VALIDNUMAUX(symindex, symbol.n_numaux) + 1) 
         {
            symbol = *CORESYMPTR(curr_mod_ptr, first_mod_symindex,
			         symindex);

	    if (inside_HLmodule && IS_695_XLATABLE(symbol) && ISFCN(symbol.n_type)) {
               aux = *COREAUXPTR(curr_mod_ptr, first_mod_symindex,
				 symindex + 1);
	       if ( ! fcn_has_a_block(curr_mod_ptr, first_mod_symindex,
				      last_mod_symindex, symindex)) {
		  /*
                   * we have discovered a module compiled without
                   * -g.  We should treat these just as we do
		   * assembler modules.
                   */
                  inside_HLmodule = FALSE;
	       }
            }

          
            if (is_section_info(&symbol)) {
	       int added_flag = FALSE;
               aux = *COREAUXPTR(curr_mod_ptr, first_mod_symindex,
				 symindex + 1);
               if (aux.x_scn.x_scnlen == 0)
                  continue; /* do not put zero-length modsects in the table */

#ifdef DEBUG1
       printf("file_sec_info_end = %d\n", file_sec_info_end);
       printf("symindex = %d, section number = %d, start = %x, length = %x\n",
               symindex, symbol.n_scnum, symbol.n_value, aux.x_scn.x_scnlen);
#endif

              if (file_sec_info_end >= 0) {
                int sec_num;

                for (sec_num = 0; sec_num <= file_sec_info_end; sec_num++) {
                  /* If there are multiple entries for the same section, then */
                  /* merge them to existing section, assume that addresses are*/
                  /* sequencial */

                  if (file_sec_info[sec_num].sec_num == symbol.n_scnum) {
                    struct file_sec_info_type holder;
         
                    added_flag = TRUE;

                    file_sec_info[sec_num].sec_len = 
                         symbol.n_value + aux.x_scn.x_scnlen -
                         file_sec_info[sec_num].sec_value;
                    holder.first_xref = file_sec_info[sec_num].first_xref;
                    holder.last_xref = file_sec_info[sec_num].last_xref;
                    file_sec_info[sec_num].first_xref = NULL;
                    file_sec_info[sec_num].last_xref = NULL;
                    find_ext_range(&sec_info[symbol.n_scnum].globlist,
                                       (LOGADR960)symbol.n_value, 
                                       ((LOGADR960)symbol.n_value) +
                                       (aux.x_scn.x_scnlen-1),
                                       &file_sec_info[sec_num].first_xref,
                                       &file_sec_info[sec_num].last_xref);
                    if (holder.first_xref != NULL) {
                      file_sec_info[sec_num].first_xref = holder.first_xref;
                    }
		    if (file_sec_info[sec_num].last_xref == NULL) {
		      file_sec_info[sec_num].last_xref = holder.last_xref;
		    }
                  }
                } /* for */
              } /* end of if (file_sec_info_end >= 0) */
              
	      if(added_flag == FALSE) {
                 file_sec_info[++file_sec_info_end].sec_num = symbol.n_scnum;
                 file_sec_info[file_sec_info_end].sec_value = symbol.n_value;
                 file_sec_info[file_sec_info_end].sec_len = aux.x_scn.x_scnlen;
                 file_sec_info[file_sec_info_end].first_xref = NULL;
                 find_ext_range(&sec_info[symbol.n_scnum].globlist,
			      (LOGADR960)symbol.n_value, 
			      ((LOGADR960)symbol.n_value) +
			       (aux.x_scn.x_scnlen-1),
			      &file_sec_info[file_sec_info_end].first_xref,
			      &file_sec_info[file_sec_info_end].last_xref);
	      }
           } /* if ( is_section_info */
         }
	 file_sec_info_end++;
         if (inside_HLmodule == FALSE) {
            goto emit_modsect;
         }


         /*----  Emit type information  BB1  */
         next_handle = FIRST_HL_HANDLE;
	 undefine_types();
         for (symindex = aft_file_symindex;
              symindex <= last_mod_symindex; 
              symindex += VALIDNUMAUX(symindex, symbol.n_numaux) + 1) {

            symbol = *CORESYMPTR(curr_mod_ptr, first_mod_symindex, symindex);

	    if( ! IS_695_XLATABLE(symbol)) {
	       /*
		* This symbol will not produce a definition in B3; hence
		* we skip it.  If it is REFERRED to by something in B3,
		* we will catch it in define_tag/define_derivation recursion.
		*/
	       continue;
            } else if (is_tag_reference(&symbol) ) {
	    /* Dereference an object's tag reference and define the tag.
	     * Note that this means that unreferenced tags will not
	     * generate 695 types.
	     */

	       long tagb;
	       aux = *COREAUXPTR(curr_mod_ptr, first_mod_symindex,symindex+1);

	       tagb = aux.x_sym.x_tagndx;
	       if ( !IS_TAG_DEFD(tagb)) {

		  /* We have something like an object of struct type, or
		   * a function returning a struct, or a function returning
		   * an enum.
		   */
		  if ( first_mod_symindex <= tagb  &&  
		      tagb <= last_mod_symindex  &&
		      IS_TAGSYMPTR(CORESYMPTR(curr_mod_ptr,
					      first_mod_symindex,tagb))) {
			 define_tag(curr_mod_ptr,
				    first_mod_symindex, last_mod_symindex,
				    tagb);
	          } else {
		     define_unktag(symindex, tagb, 
				   aux.x_sym.x_misc.x_lnsz.x_size, source_mod_first);
		  }
		      
	       }
	    }

	    /* further, the entity at symindex can have a derivation
	     * chain which must be defined, or it could be a function 
	     * definition.
	     */


            if (IS_SPECIAL_PROCEDURE(symbol) &&
                (DT_KIND(symbol.n_type,1) == DT_NON)) {

               SYMENT *spec_symbol_coreptr =
                  CORESYMPTR(curr_mod_ptr, first_mod_symindex, symindex);
               /* The V3 tools have a bug: some sysprocs
                * (and leafprocs maybe too) have a NULL
                * type which does not appear
                * to be a function definition.  Here, we fix our in-core copies
                * to be a function returning T_NULL.
                */
               spec_symbol_coreptr->n_type = symbol.n_type = DT_FCN << N_BTSHFT;

            } 

	    if (is_derived_xlat(symbol.n_type)) {
	       define_derivation(curr_mod_ptr, 
				 first_mod_symindex, last_mod_symindex,
                                 symindex, &symbol);
	    } else {
	       /* We have something which does not generate in the 
		* B1, such as an object of a B.I.TYpe; no h/l type gen 
		* needed.
		*/
	    }
         }  /*  for BB1  */

	 /* Produce B1 entries for data externals declared within
	  * module-sections of this module
	  */
         for (sec_num = 0; sec_num < file_sec_info_end; sec_num++) {
	    cur_ref = file_sec_info[sec_num].first_xref;
            if (cur_ref == NULL) 
               continue;
	    for ( cur_ref = file_sec_info[sec_num].first_xref;
		 cur_ref->prev != file_sec_info[sec_num].last_xref;
		 cur_ref = cur_ref->next) {
	       symindex = ext_mod_index + (cur_ref->sym-ext_mod_ptr);
	       symbol = *CORESYMPTR(ext_mod_ptr, ext_mod_index, symindex);
	       if( ! IS_695_XLATABLE(symbol)) {
	       /*
		* This symbol will not produce a definition in B3; hence
		* we skip it.  If it is REFERRED to by something in B3,
		* we will catch it in define_tag/define_derivation recursion.
		*/
		  continue;
	       } else if (is_tag_reference(&symbol) ) {
		  long tagb;
		  aux = *COREAUXPTR(ext_mod_ptr, ext_mod_index, symindex+1);
		  tagb = aux.x_sym.x_tagndx;
		  if ( !IS_TAG_DEFD(tagb)) {

		     /* We have something like an object of struct type, or
		      * a function returning a struct, or a function returning
		      * an enum.
		      */
		     if ( first_mod_symindex <= tagb  &&  
			 tagb <= last_mod_symindex  &&
			 IS_TAGSYMPTR(CORESYMPTR(curr_mod_ptr,
						 first_mod_symindex, tagb))) {
                         define_tag(curr_mod_ptr,
				    first_mod_symindex, last_mod_symindex,
				    tagb);
		      } else {
			 define_unktag(symindex, tagb, 
				       aux.x_sym.x_misc.x_lnsz.x_size, source_mod_first);
		      }
 	          }
	       }

	       if (is_derived_xlat(symbol.n_type))

		  define_derivation(ext_mod_ptr, ext_mod_index, 
                                    sentinel_symindex-1, symindex, &symbol);
	       else
		  /* No type def associated with this global object */;

	    }
         }


         /* Emit extern information in B3 */
         for (sec_num = 0; sec_num < file_sec_info_end; sec_num++) {
	    cur_ref = file_sec_info[sec_num].first_xref;
            if (cur_ref == NULL) 
               continue;
	    for ( cur_ref = file_sec_info[sec_num].first_xref;
		 cur_ref->prev != file_sec_info[sec_num].last_xref;
		 cur_ref = cur_ref->next) {
	       symindex = ext_mod_index + (cur_ref->sym-ext_mod_ptr);
	       symbol = *CORESYMPTR(ext_mod_ptr, ext_mod_index, symindex);

	       if (IS_695_XLATABLE(symbol)) {
		  char*  symbol_name;
		  HPSYM  hp_symbol;
		  
		  if (VALIDNUMAUX(symindex, symbol.n_numaux) > 0)
		     aux = *COREAUXPTR(ext_mod_ptr, ext_mod_index,symindex+1);
		  symbol_name  = ldgetname(inldfile_ptr, &symbol);
		  hp_symbol.name = (inside_HLmodule == TRUE 
				    && *symbol_name == '_'
				    ? symbol_name + 1 : symbol_name);

		  if ( !gen_attribute(symindex,
				      symbol.n_sclass, symbol.n_value, 
				      &hp_symbol.attribute,
				      &hp_symbol.asnval,
				      0) )
		     continue; /* ATN/ASN generation failed for some reason */
		  

		  hp_symbol.type = hl_type(&symbol, &aux, symindex);

#ifdef DEBUG
		  fprintf(stdout,
			  "V %s %d\n", hp_symbol.name, hp_symbol.asnval);
#endif
		  if (hp_putcsym(&hp_symbol) < 0)
		     abort();
	       }  /* IS_695_XLATABLE  */

	    } /* for */
         }

         /*----  Emit symbols and/or scoping (B4/B6) info into a B3 */
	   
     {
	 int in_bf_ef_scope = 0;

         for (symindex = aft_file_symindex; symindex <= last_mod_symindex; 
              symindex += VALIDNUMAUX(symindex, symbol.n_numaux) + 1) {

            symbol = *CORESYMPTR(curr_mod_ptr, first_mod_symindex, symindex);

	    if (IS_695_XLATABLE(symbol)) {
               HPSYM  hp_symbol;
	       char symbol_name[BUFSIZ + SYMNMLEN];


               strcpy(symbol_name, ldgetname(inldfile_ptr, &symbol));

	       /* As Xray and other 695 debuggers and ICE's have no */
	       /* use of the following symbols, save symbol table */
	       /* space and don't translate them */
	       if (!strcmp(symbol_name, "___gnu_compiled_c") ||
		   !strcmp(symbol_name,"ic_name_rules.")     ||
		   !strcmp(symbol_name,"gcc2_compiled.") ) {
		 continue;
	       }
	       if (symbol_name[0] == '.'  &&  IS_FLOCAL(symbol)) {

		  if (!strcmp(symbol_name, ".argptr") && 
		      (symbol.n_sclass==C_REGPARM)) {
		     /* An argument block pointer in a register is
		      * saved for expressing register-based offsets to
		      * C_ARG symbols.
		      */
		     cur_argptr = symbol.n_value;
		     /* ... and the .argptr symbol is otherwise ignored */
		  }
	          continue;
		  /* ignore pseudo-symbols masquerading as C_AUTO variables.
		   * Example: '.target' is a C_AUTO.
		   */
 	       }
	       
	       if (symbol.n_numaux /*numaux is known valid*/  > 0)
		  aux = *COREAUXPTR(curr_mod_ptr, first_mod_symindex, 
				    symindex + 1);

	       if (ISFCN(symbol.n_type)) {
		  /* 
		   * Look ahead to find out whether a .bf follows;
		   * if so we should open a B4 or a B6 
		   */
		  saved_begin_block = symbol.n_value;
	          if (fcn_has_a_block(curr_mod_ptr, first_mod_symindex,
				      last_mod_symindex, symindex)) {
		     char* fname = symbol_name;

		     if (inside_HLmodule == TRUE)
			++fname;
		     if (0>hp_openblock(fname, IS_695_GLOBAL(symbol),
                                  TYPE_HANDLE(symindex), symbol.n_value))
                        abort();
		     /* At this point, there is no currently defined argument
		      * block pointer.  Initialize the current to be invalid.
		      */
		     cur_argptr = COFFREG_INVALID;
		     
		     if (IS_SPECIAL_PROCEDURE(symbol)) {
			AUXENT *aux2 = 
			   COREAUXPTR(curr_mod_ptr,
				      first_mod_symindex, symindex+2);
			long info2 = (symbol.n_sclass == C_SCALL ?
		           aux2->x_sc.x_stindx:
			   (aux2->x_bal.x_balntry - symbol.n_value));
 					  
			put_procmark(HPATN_PMISC, symbol.n_sclass, info2);
		     }

		     continue; /* the for loop after opening a B4 or B6 */
		  }
	       }

	       /* if a function symbol gets here, it is not followed by
		* .bf/.ef information.
		*/
	       if ( symbol.n_sclass == C_LABEL && !IS_HL_LABEL(symbol_name)){
		  /* 
		   * Ignore low level labels in high level modules.
		   */
		  continue; /* the for loop */		   
	       }
	       if ( !gen_attribute(symindex,
				   symbol.n_sclass, symbol.n_value, 
				   &hp_symbol.attribute,
				   &hp_symbol.asnval,
				   in_bf_ef_scope) )
		  continue; /* ATN/ASN generation failed for some reason */
   
	       hp_symbol.type = hl_type(&symbol, &aux, symindex);

               hp_symbol.name = ((inside_HLmodule == TRUE 
				  && symbol_name[0] == '_'
				  && symbol.n_sclass != C_LABEL)
                                 ? &symbol_name[1] : &symbol_name[0]);
#ifdef DEBUG
               fprintf(stdout, "V %s %d\n", hp_symbol.name, hp_symbol.asnval);
#endif
               if (hp_putcsym(&hp_symbol) < 0)
                  abort();
	       else
		  continue; /* the for loop */
              /* IS_695_XLATABLE  */

            } else if (is_bb(&symbol) || is_bf(&symbol)) {
		saved_begin_block = symbol.n_value;
		if (is_bf(&symbol))
			in_bf_ef_scope = 1;
	       /* open a nameless static block */
               if (is_bb(&symbol) && (0>hp_openblock("\0", 0, 0, symbol.n_value)))
                  abort();
            } else if (is_ef(&symbol) || is_eb(&symbol)) {
			  /* close either a function or nameless block */
	       /* Close the block with its ending address, unless there
		* is a (nonsensical) 0 value.
		*/
		if (is_ef(&symbol))
			in_bf_ef_scope = 0;
               if (0>hp_closeblock((symbol.n_value == 0)?
			     0:
				   ((saved_begin_block < ((LOGADR960)symbol.n_value) ?
				    ((LOGADR960)symbol.n_value-1) :
				   (LOGADR960)symbol.n_value))))
                  abort();
	        
            }
	}
     }
	  
         /*----  Emit line number information BB5  */
#ifdef DEBUG2
	 printf("Opening B5 for source module '%s'.\n", source_path);
#endif

	 first_modline = TRUE; /* triggers opening a B5 on the first source
				* line.
				*/
	 if (source_path && (source_path != source_buf))
	    free(source_path); /* Release storage associated with path name */
     {
	 LOGADR960 function_addr;

         for (symindex = aft_file_symindex; symindex <= last_mod_symindex; 
              symindex += VALIDNUMAUX(symindex, symbol.n_numaux) + 1) 
	     {
		 LINENO         linent;
		 unsigned short bf_lnno;

		 symbol = *CORESYMPTR(curr_mod_ptr, first_mod_symindex, symindex);
		 if (ISFCN(symbol.n_type)) {
		     if (IS_LEAF_PROC(symbol)) {
			 /* leaf procedure => first instruction that satisfies
			  * both CALL and BALL entries will be the BAL entry point
			  * from the 2nd aux entry.
			  */
			 aux = *COREAUXPTR(curr_mod_ptr, first_mod_symindex, 
					   symindex+2);
			 function_addr = aux.x_bal.x_balntry; 
		     } else {
			 /* not a leaf procedure => function symbol value is label */
			 function_addr = symbol.n_value;
		     }

		     linit(symindex);
		     /* If the above fails, it is not serious -- it only means
		      * that there is no lines for this function, and that
		      * lnext below will fail as well.
		      */
		 } else if (is_bf(&symbol)) {
		     /*
		      * this bf is associated with the last symbol which
		      * produced TRUE from ISFCN, above.
		      */
		     bool first_line = TRUE;
		     aux = *COREAUXPTR(curr_mod_ptr, first_mod_symindex,symindex+1);
		     bf_lnno = aux.x_sym.x_misc.x_lnsz.x_lnno;
		     while (lnext(&linent) == SUCCESS)
			 {
#ifdef DEBUG2
			     fprintf(stdout, "L %d %#x\n", bf_lnno + linent.l_lnno - 1, 
				     linent.l_addr.l_paddr);
#endif

			     if (first_modline) {
				 /* Open a B5 block for the source module's first line */
				 if (0>hp_openline(source_path)) {
				     abort();
				 }
				 first_modline = FALSE;
			     }
			     if (0>hp_putline(bf_lnno + linent.l_lnno - 1, 
					      first_line?function_addr:linent.l_addr.l_paddr))
				     abort();
			     else
				     first_line = FALSE;
			 }
		 }
	     }
     }

         emit_modsect:

       if(amc_mri == FALSE || inside_HLmodule == FALSE) {
         /*----  Emit module section information BB10  */
	 if (file_sec_info_end > 0) {
	    /* There exists at least 1 non-empty file section, so
	     * open the B10 with the identification of the assembler.
	     */
	    if (0>hp_putasmid(asm_tool.id,
			(asm_tool.id!=HPTOOL_UNK?asm_tool.vers:NULL),
			(asm_tool.id!=HPTOOL_UNK?&asm_tool.utime:NULL)))
               abort();
	 }
	 if(amc_mri == FALSE) {
	     for (sec_num = 0; sec_num < file_sec_info_end; sec_num++) {
	      if (0>hp_putmodsect(file_sec_info[sec_num].sec_num,
			    file_sec_info[sec_num].sec_value,
			    file_sec_info[sec_num].sec_len,0))
		   abort();
	     }
	 }

         /*----  Emit assembly-level symbols if inside assembly module */
         if (inside_HLmodule == FALSE) {

            for (symindex = aft_file_symindex; 
                 symindex <= last_mod_symindex; 
                 symindex  = emit_b10sym(curr_mod_ptr,
					 first_mod_symindex, symindex))
	       ;
	    

	    for (sec_num = 0; sec_num < file_sec_info_end; sec_num++) {
	       cur_ref = file_sec_info[sec_num].first_xref;
	       if (cur_ref == NULL) 
		  continue;
	       for ( cur_ref = file_sec_info[sec_num].first_xref;
		    cur_ref->prev != file_sec_info[sec_num].last_xref;
		    cur_ref = cur_ref->next) {
		  /* cur_ref points to .first_xref through .last_xref */
		  symindex = ext_mod_index + (cur_ref->sym-ext_mod_ptr);
		  emit_b10sym(ext_mod_ptr, ext_mod_index, symindex);

	       } /* for */
	    }
	 }
       }
         if (0>hp_closemod()) /* Terminate the B1/B3/B10 group */
            abort();

	 /* Free per-module core resources */
         CHKFREE(curr_mod_ptr);
	 for (sec_num = 0; sec_num < file_sec_info_end; sec_num++) {
	    EXTREF* first_ref = file_sec_info[sec_num].first_xref;

	    if (first_ref == NULL) 
	       continue;
	    else 
	       free_ext_range(first_ref,file_sec_info[sec_num].last_xref);
	 } /* for(;;) */

      }  /*  for all modules except externals */

      /* Free the index-bounds; we are done with source modules */
      for (source_mod_cur = source_mod_first; 
	   source_mod_cur != NULL;
           source_mod_cur = source_mod_first) {
         source_mod_first = source_mod_cur->next;
	 free(source_mod_cur);
      }
      source_mod_first = source_mod_last = NULL;

#ifdef DEBUG
      fprintf(stdout, "----  Uninitialized global variables (dummy bss)\n");
#endif      

      if (1) {
	  int global_non_init_module_count = 0;

	  for (scn=1; scn <= no_scns; scn++) {
	      /* Search for sections containing COMMON symbols in them.
		 These section will have global symbols as well as size etc. */
	      struct sec_info_type *s = &sec_info[scn]; /* Potential section */
	      int foundone = 0;			    /*  with common symbols in it. */

	      if (s->sec_size == 0)
		      /* no .bss section to insert globals into */
		      continue;
	      if (sentinel_symindex <= first_ext_symbol(&s->globlist, &symbol))
		      /* no globals to process */
		      continue;
	      foundone = 1;
	      while ((LOGADR960)symbol.n_value < s->sec_paddr )
		      if (sentinel_symindex <= 
			  next_ext_symbol(&s->globlist, &symbol)) {
			  /* ran out of globals while looking for 1st in this section. */
			  foundone = 0;
			  break;
		      }
	      if (!foundone)
		      continue;
	      
	      if ((LOGADR960)symbol.n_value >= s->sec_paddr+s->sec_size )
		      /* symbol range is beyond the end of .bss */
		      continue;
	      
	      /* Assert: symbol.n_value is the address of the
	       * first common symbol allocated to section s.
	       * Define a segment for the globals between
	       * this address and the inclusive-end address of s:
	       */
	      file_sec_info[0].sec_num = scn;
	      file_sec_info[0].sec_value = symbol.n_value;
	      file_sec_info[0].sec_len = s->sec_size -
		      ((LOGADR960)symbol.n_value - s->sec_paddr);
	      find_ext_range(&s->globlist,
			     (LOGADR960)symbol.n_value, 
			     ((LOGADR960)symbol.n_value) +
			     (file_sec_info[0].sec_len-1),
			     &file_sec_info[0].first_xref,
			     &file_sec_info[0].last_xref);
	      if (1) {
		  char gnibuff[32];
		  
		  sprintf(gnibuff,".global_non_init.%d",global_non_init_module_count++);
		  if (0>hp_openmod(gnibuff, 0))
			  abort();
	      }
	      /*----  Emit type information for dummy BSS section  BB1  */
	      llsyms = FALSE;  /* no low-level symbols seen yet */
	      next_handle = FIRST_HL_HANDLE;
	      undefine_types();
	      
	      /* .global_non_init B1 */
	      for ( cur_ref = file_sec_info[0].first_xref;
		   cur_ref->prev != file_sec_info[0].last_xref;
		   cur_ref = cur_ref->next) {
		  char *symbol_name;
		  
		  symindex = ext_mod_index + (cur_ref->sym-ext_mod_ptr);
		  symbol = *CORESYMPTR(ext_mod_ptr, ext_mod_index, symindex);
		  symbol_name = ldgetname(inldfile_ptr, &symbol);
		  if (*symbol_name != '_') {
		      llsyms = TRUE;
		      continue;
		  } 
		  
		  if( ! IS_695_XLATABLE(symbol)) {
		      /*
		       * This symbol will not produce a definition in B3; hence
		       * we skip it.  If it is REFERRED to by something in B3,
		       * we will catch it in define_tag/define_derivation recursion.
		       */
		      continue;
		  } else if (is_tag_reference(&symbol) ) {
		      long tagb, tage;
		      
		      aux = *COREAUXPTR(ext_mod_ptr, ext_mod_index, symindex+1);
		      tagb = aux.x_sym.x_tagndx;
		      if (!IS_TAG_DEFD(tagb)) {
			  if (tagb >= 0  &&  tagb < sentinel_symindex
			      && is_tagi(tagb)) {
			      SYMENT *tag_ptr = alloc_tag(tagb, &tage);
			      
			      define_tag(tag_ptr, tagb, tage, tagb);
			      free(tag_ptr);
			  } else {
			      define_unktag(symindex, tagb, 
					    aux.x_sym.x_misc.x_lnsz.x_size, source_mod_first);
			  }
		      }
		  }
		  
		  /* Assert: if the symbol at symindex refers to a tag, that tag
		   * now has a 695 type defined for it.
		   */
		  if ( is_derived_xlat(symbol.n_type) )
			  define_derivation(ext_mod_ptr, ext_mod_index, sentinel_symindex-1,
					    symindex, &symbol);
		  
	      }  /*  for BB1  */
	      
	      
	      /* .global_non_init B3 */
	      for ( cur_ref = file_sec_info[0].first_xref;
		   cur_ref->prev != file_sec_info[0].last_xref;
		   cur_ref = cur_ref->next) {
		  symindex = ext_mod_index + (cur_ref->sym-ext_mod_ptr);
		  symbol = *CORESYMPTR(ext_mod_ptr, ext_mod_index, symindex);
		  
		  if (IS_695_XLATABLE(symbol)) {
		      char*  symbol_name;
		      HPSYM  hp_symbol;
		      
		      if (VALIDNUMAUX(symindex, symbol.n_numaux) > 0)
			      aux = *COREAUXPTR(ext_mod_ptr, ext_mod_index, symindex + 1);
		      symbol_name  = ldgetname(inldfile_ptr, &symbol);
		      
		      if (*symbol_name != '_') {
			  llsyms = TRUE;
			  continue;
		      } 
		      /* symbol name contains a leading '_' */
		      
		      hp_symbol.name = symbol_name + 1;
		      
		      if ( !gen_attribute(symindex,
					  symbol.n_sclass, symbol.n_value, 
					  &hp_symbol.attribute,
					  &hp_symbol.asnval,
					  0) )
			      continue; /* ATN/ASN generation failed for some reason */
		      
		      hp_symbol.type = hl_type(&symbol, &aux, symindex);
#ifdef DEBUG
		      fprintf(stdout, "V %s %d\n", hp_symbol.name, hp_symbol.asnval);
#endif
		      if (hp_putcsym(&hp_symbol) < 0)
			      abort();
		  }  /* IS_695_XLATABLE  */
	      }  /*  for  BB3  */
	      
	      if (0>hp_putasmid(HPTOOL_UNK, NULL, NULL))
		      abort();
	      if(amc_mri == FALSE) {
		  if (0>hp_putmodsect(file_sec_info[0].sec_num, 
				      file_sec_info[0].sec_value, 
				      file_sec_info[0].sec_len,2))
			  abort();
	      }
	      
	      if (llsyms) {
		  /* there were low-level global symbols, emit them in the
		   * B10.
		   */
		  
		  for ( cur_ref = file_sec_info[0].first_xref;
		       cur_ref->prev != file_sec_info[0].last_xref;
		       cur_ref = cur_ref->next) {
		      symindex = ext_mod_index + (cur_ref->sym-ext_mod_ptr);
		      symbol = *CORESYMPTR(ext_mod_ptr, ext_mod_index, symindex);
		      if ( * ldgetname(inldfile_ptr, &symbol)  != '_' ) {
			  emit_b10sym(ext_mod_ptr, ext_mod_index, symindex);
		      }
		  }
	      }
	      
	      if (0>hp_closemod())  /*  Close dummy BSS module  */
		      abort();
	      free_ext_range(file_sec_info[0].first_xref,
			     file_sec_info[0].last_xref);
	  }
      } /* End of for (scn=0 ... */

      /* 
       * the completion of debug-info output means we can free the
       * auxiliary extlists, and the external module which they pin.
       */
      for (scn = 1; scn <= no_scns; scn++)
	 free_ext_symbols(&sec_info[scn].globlist);
      CHKFREE(ext_mod_ptr);      
      undefine_types(); /* Remove info about previous tags and do not
			 * define any more.
			 */
   }
   
   /*----  Write section information */
   {
      SCNHDR secthead;
      HPIMAGE_SEG segment;

      for (scn = 1; scn <= no_scns; scn++) {
         /*---- More section information to read ? */
         if (ldshread(inldfile_ptr, scn, &secthead) == FAILURE) {
            break;
	 } else if (secthead.s_scnptr > 0) {
	    /* section data in file */
	    segment.id = scn;
	    segment.size = secthead.s_size;
	    segment.stream = infile_ptr;
	    fseek(infile_ptr, secthead.s_scnptr, 0);
	    if (hp_putabsdata(&segment) < 0) {
	       abort();
	    }
	 } else if ((SHF_CONTENT & secthead.s_flags) ==  STYP_BSS) {
	    /* BSS without explicit data with file gets default fill
	     * pattern of 00.
	     */
	    if (hp_putabs0(scn, secthead.s_size) < 0 ) {
	       abort();
	    }
	 }
      } /* for */
   }

   /*----  Close 695 file  */
   {
      AOUTHDR aouthdr;
      if (HEADER(inldfile_ptr).f_opthdr > 0) {
         if (ldohseek(inldfile_ptr) == FAILURE) {
            error_out(error_prefix, NO_OFLHD, NO_SUB, infile_name);
            abort();
         }
         if (fread(&aouthdr, sizeof(aouthdr), 1, infile_ptr) != 1) {
            error_out(error_prefix, RD_OFLHD, NO_SUB, infile_name);
            abort();
         }
         if (0>hp_close(aouthdr.entry))
            abort();
      } else {
         error_out(error_prefix, NO_OFLHD, NO_SUB, infile_name);
         abort();
      }
   }
}

/******************************************************************************/

main(argc, argv)
   int    argc;
   char** argv;
{
   static char module[] = "<cvt960.c>";

   argc = get_response_file(argc,&argv);

   error_prefix = (char *)chkalloc(strlen(argv[0])+1+strlen(module)+1);
   strcat(strcpy(error_prefix, argv[0]), module);

   if (setflags(argc, argv) == FAIL) {
      usage();
      abort();
   }
   if (filesame(infile_name, outfile_name) == 0) {
      /* The input file infile_name and the output file outfile_name are the
       * same file.
       */
      error_out(error_prefix, FILESAME, NO_SUB, infile_name, outfile_name);
      abort();
   }
   
   init_n = NN_FIRSTDYN;
   convert_to_695(argc, argv);
   exit(0); /* successful termination */
}
