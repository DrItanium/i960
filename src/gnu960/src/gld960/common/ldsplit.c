
/* Copyright (C) 1991 Free Software Foundation, Inc.
 *
 * This file is part of GLD, the Gnu Linker.
 *
 * GLD is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 1, or (at your option)
 * any later version.
 *
 * GLD is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GLD; see the file COPYING.  If not, write to
 * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include "sysdep.h"
#include "bfd.h"
#include "ld.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldmisc.h"

extern bfd *output_bfd;
extern ld_config_type config;
extern lang_statement_list_type lang_output_section_statement;

/* This file contains the code that splits sections in COFF output files
if they threaten to get more than 64K line numbers or relocation entries.
This is a monstrous task, as can be seen by the byzantine convolutions of
the code below. This is because the task seems to me to require rewiring
by hand the object-oriented structure of the output sections that are being
split. If you see a cleaner way to do the job, please feel free to replace
what is here. -- Roberta Taussig, 9/21/92 */

/* This routine generates a guaranteed-unique name for the section that will
be created after the original is split. */
char *
DEFUN(find_new_section_name,(current_name),
CONST char *current_name)
{ 

	char *name1, *name2;
	int namelen, emptychars, maxval, thisval, loop;
	char nullterm;
	boolean found_new_name;

	nullterm = '\0';
	found_new_name = false;
	/* name2 will hold the new name */
	name2 = (char *)ldmalloc(9);
	namelen = strlen(current_name);
	/* name1 will be the copy of the name that will get
	shortened if necessary to serve as the base of the new
	name */
	name1 = (char *)ldmalloc(namelen+1);
	strcpy(name1,current_name);
	/* section names can be at most 8 characters long;
	emptychars says how many spaces are left at the end to
	play with */
	emptychars = 8 - namelen;
	maxval = 1;
       	for (loop=0;loop<emptychars;loop++){
       	      	maxval *= 10;
	}
	while (!found_new_name) {

		boolean same_as_old_name;

		/* This loop generates new base names from the original
		name so the inner loop can glom numbers onto it. */
		same_as_old_name = false;
		thisval = 1;
        	while (!found_new_name && (thisval < maxval)) {

			asection *sects;

			/* This loop runs through all variations that can be
			generated by putting numbers into the space left at
			the end of the base name in name1. */
               		sprintf(name2,"%s%d%c",name1,thisval,nullterm);
			/* see whether there is already a section with
			this name */
			sects = output_bfd->sections;
			while (sects && !found_new_name) {
				/* Compare this name to all the section
				names we already have. */
				if (!strcmp(sects->name,name2)) {
					same_as_old_name = true;
					break;
				}
				else {
					sects = sects->next;
				}
			}
			if (!same_as_old_name) {
				found_new_name = true;
			}
			thisval++;
			same_as_old_name = false;
       		}
		if (found_new_name) {
			break;
		}
		/* Couldn't find a name with that base,
		cut off a letter and try again */
		namelen--;
		if (!namelen) {
			printf("Unable to find valid name for split-off section, unable to continue to add sections to current section. Aborting.\n");
			exit(0);
		}
		name1[namelen]=nullterm;
		maxval *= 10;
	}
       	free(name1);
	return (name2);
}

/* This routine is used when it is necessary to split a COFF output section
to avoid overflowing the line number or relocation entry count fields in
the section header. All the machinery that initializes it and joins it to the
lists of other statements is done here instead of through the usual routines
because it has to look as if it were defined immediately after the original
section. */

lang_output_section_statement_type *
DEFUN(hand_craft_new_output_section_statement,(name,output),
    char *name AND
    lang_output_section_statement_type *output)
{

	lang_output_section_statement_type *new_sec = 
		(lang_output_section_statement_type *)
		ldmalloc(sizeof(lang_output_section_statement_type));
	section_userdata_type *new_userdata = (section_userdata_type *)
		ldmalloc((bfd_size_type)(sizeof(section_userdata_type)));


	new_sec->header.type = lang_output_section_statement_enum;

	/* The next two statements insert the new output section into the
	overall list of statements after the one being split */ 
	new_sec->header.next = output->header.next;
	output->header.next = (lang_statement_union_type *)new_sec;

	/* The next two statements insert the new output section into the
	list of output_section_statements after the one being split */
	new_sec->next = output->next;
	output->next = (union lang_statement_union *)new_sec;

	new_sec->processed = new_sec->section_was_split = false;
	new_sec->addr_tree = (etree_type *)NULL;
	new_sec->memspec = output->memspec;
	new_sec->flags = output->flags;
	new_sec->region_name = output->region_name;
	new_sec->region_attributes = output->region_attributes;
	new_sec->fill = output->fill;

	/* This makes it look like the old section and the new section
	are in the same GROUP, which makes sure the new section gets
	located close after the old section, an operation that is
	difficult elsewise because the old section doesn't yet know
	its own size and so cannot tell us what the new section's
	start address should be. Note that we still need to do some
	finagling to get the space that does happen filled in with a
	constant value so the user's checksums will work. The boolean
	section_was_split cues us later that we need to worry about it. */
	new_sec->next_in_group = output->next_in_group;
	if (!new_sec->next_in_group) {
		/* The end_of_group signal is 0xFFFFFFFF, not 0x0, which
		we have to fake if we just created a group that didn't
		exist before. */
		new_sec->next_in_group = (struct lang_output_section_statement_struct *)0xFFFFFFFF;
	}
	output->next_in_group = new_sec;

	new_sec->bfd_section = bfd_make_section(output_bfd, name);
	if (new_sec->bfd_section == (asection *)NULL) {
		info("%Ffailed to create new section %s to contain overflow from %s\n",
					name,output->name);
	}
	new_sec->bfd_section->output_section = new_sec->bfd_section;
	new_sec->bfd_section->flags = output->bfd_section->flags;
	new_sec->bfd_section->alignment_power =
		output->bfd_section->alignment_power;

	get_userdata(new_sec->bfd_section) = (PTR *)new_userdata;

        new_sec->children.head = (lang_statement_union_type *)NULL;
        new_sec->children.tail = &(new_sec->children.head);

	new_sec->name = name;

	return new_sec;
}

/* This routine changes the output_section fields of all the input sections
reassigned to a new output section in reassign_links() */

static void
DEFUN(update_adopted_children,(this_wild, new_section_addr),
	lang_statement_union_type *this_wild AND
	asection *new_section_addr) 
{
	lang_statement_union_type *next_step;
	lang_input_section_type *inside_step;

	next_step = this_wild;
	while (next_step) {
		if (next_step->header.type == lang_input_section_enum) {
			next_step->input_section.section->output_section =
				new_section_addr;
		}
		if (next_step->header.type == lang_wild_statement_enum) {
			inside_step = (lang_input_section_type *)next_step->wild_statement.children.head;
			while (inside_step) {
				inside_step->section->output_section = new_section_addr;
				inside_step = (lang_input_section_type *)inside_step->header.next;
			}
		}
		next_step = next_step->header.next;
	}
	return;
}

/* This routine, which does all the link shuffling involved in splitting
sections, returns a pointer to a union lang_statement_union because it may
need to create a new wild_statement to contain the remnants of the one
pointed to by this_wild if we are in the middle of processing the children
of this_wild when we need to do the split. */

static union lang_statement_union *
DEFUN(reassign_links,(prev_top, new_top, prev_wild, this_wild, prev_input_sec_addr, this_input_sec),
	lang_output_section_statement_type *prev_top AND
	lang_output_section_statement_type *new_top AND
	lang_statement_union_type *prev_wild AND
	lang_statement_union_type *this_wild AND
	lang_input_section_type **prev_input_sec_addr AND
	lang_input_section_type *this_input_sec)
{
	union lang_statement_union *new_wild;

	new_wild = (union lang_statement_union *)NULL;
	new_top->children.tail = prev_top->children.tail;
	/* If we are at an input section that is a child of the output
	section; or if we are at the first input section inside a wild
	statement that is a child of the output section; we can do a
	relatively simple reassignment. */
	if ((this_wild->header.type == lang_input_section_enum) ||
		(!(*prev_input_sec_addr))) {
		new_top->children.head = this_wild;
		/* Change output_section references in children assigned to
		new output section. */
		update_adopted_children(this_wild,new_top->bfd_section);
		
		prev_wild->header.next = (lang_statement_union_type *)NULL;
		prev_top->children.tail = &(prev_wild->header.next);
		return(this_wild);
	}
	/* We need to create a new wild statement to take over the rest of
	the children of the wild statement we are currently in the middle
	of. This is somewhat more complex. */

	/* create new wild statement, making it the first child of the new
	output section */
	new_wild = (lang_statement_union_type *) ldmalloc(sizeof(lang_statement_union_type));
	new_wild->header.type = this_wild->header.type;

	new_wild->header.next = this_wild->header.next;
	new_top->children.head = new_wild;
	new_top->children.tail = prev_top->children.tail;

	/* Terminate the list of the children of the old output section */
	prev_top->children.tail = &this_wild->header.next;
	this_wild->header.next = (lang_statement_union_type *)NULL;

	/* Make the remaining children of the old output section into the
	children of the new wild statement. */
	new_wild->wild_statement.children.head = (lang_statement_union_type *)this_input_sec;
	new_wild->wild_statement.children.tail = this_wild->wild_statement.children.tail;

	/* Terminate list of children of the current wild statement */
	this_wild->wild_statement.children.tail = (lang_statement_union_type **)prev_input_sec_addr;
	(*prev_input_sec_addr)->header.next = (lang_statement_union_type *)NULL;

	update_adopted_children(new_wild,new_top->bfd_section);
	
	return(new_wild);
}


#define SIXTY_FOUR_K 0xffff

void
DEFUN_VOID(check_for_section_split)
{

	/* Run through list of output sections looking for any to
	which more than 64K line numbers or relocation entries has
	been assigned; if any such are found, split them to avoid
	overflowing the fields of the COFF section header */

	lang_output_section_statement_type *out_sect, *old_out_sect;

	out_sect = (lang_output_section_statement_type *)
		lang_output_section_statement.head;
	while (out_sect) {

		int lines, relocs;
		union lang_statement_union *nextgen, *previous_next;

		if (out_sect->flags & LDLANG_DSECT) {
			/* DSECTs don't have line numbers or
			relocation entries and cannot need to be
			split */
			out_sect = (lang_output_section_statement_type *)
				out_sect->next;
			continue;
		}
		lines = relocs = 0;
		nextgen = out_sect->children.head;
		previous_next = (union lang_statement_union *)NULL;
		while (nextgen) {
			
			char *newname;

			if (nextgen->header.type == lang_input_section_enum) {

				/* This if handles the case where a child of
				an output_section is simply an input_section. */

				if ((lines + nextgen->input_section.section->lineno_count) > SIXTY_FOUR_K) {
				        char *old_name = (char *)out_sect->name;

					old_out_sect = out_sect;
					old_out_sect->name = newname = find_new_section_name(old_name);
					old_out_sect->bfd_section->name = newname;
					out_sect = hand_craft_new_output_section_statement(old_name,
											   out_sect);
                                        nextgen = reassign_links(old_out_sect,
						out_sect,
                                                previous_next,
                                                nextgen,
                                                (lang_input_section_type **)NULL,
                                                (lang_input_section_type *)NULL);
					old_out_sect->section_was_split = true;
                                        previous_next = (union lang_statement_union *)NULL;
                                        lines = relocs = 0;
				}
				if (((config.relocateable_output)) &&
					(relocs + nextgen->input_section.section->reloc_count) > SIXTY_FOUR_K) {
				        char *old_name = (char *)out_sect->name;

					old_out_sect = out_sect;
					old_out_sect->name = newname = find_new_section_name(out_sect->name);
					old_out_sect->bfd_section->name = newname;
					out_sect = hand_craft_new_output_section_statement(old_name,
											   out_sect);
                                        nextgen = reassign_links(old_out_sect,
                                                out_sect,
                                                previous_next,
                                                nextgen,
                                                (lang_input_section_type **)NULL,
                                                (lang_input_section_type *)NULL) ;
					old_out_sect->section_was_split = true;
                                        previous_next = (union lang_statement_union *)NULL;
					lines = relocs = 0;
				}
/* Note that, if a new section has been created, lines and relocs need to be
reinitialized. */
				lines += nextgen->input_section.section->lineno_count;
				relocs += nextgen->input_section.section->reloc_count;
			}
			else if (nextgen->header.type == lang_wild_statement_enum) {

				/* This if handles the case where the child of
				the output_section is a wild_statement, whose
				input_section children must be tested to see
				whether any of them contribute too many line
				numbers or relocation entries to fit into the
				old output section */
					
				lang_input_section_type *thirdgen, *previous_third;
	
				thirdgen = (lang_input_section_type *)nextgen->wild_statement.children.head;
				previous_third = (lang_input_section_type *)NULL;
				while (thirdgen) {

					if ((lines + thirdgen->section->lineno_count) > SIXTY_FOUR_K) {
					        char *old_name = (char *)out_sect->name;

						old_out_sect = out_sect;
						old_out_sect->name = newname =
							find_new_section_name(out_sect->name);
						old_out_sect->bfd_section->name = newname;
						out_sect = hand_craft_new_output_section_statement(old_name,
												   out_sect);
						nextgen = reassign_links(old_out_sect, 
							out_sect,
							previous_next,
							nextgen,
							&previous_third,
							thirdgen);
						previous_third = (lang_input_section_type *)NULL;
						old_out_sect->section_was_split = true;
						previous_next = (union lang_statement_union *)NULL;
						lines = relocs = 0;
						}
						
					if (((config.relocateable_output)) &&
						 ((relocs + thirdgen->section->reloc_count) > SIXTY_FOUR_K)) {
					    char *old_name = (char *)out_sect->name;

					    old_out_sect = out_sect;
					    old_out_sect->name = newname =
						    find_new_section_name(out_sect->name);
					    old_out_sect->bfd_section->name = newname;
					    out_sect = hand_craft_new_output_section_statement(old_name,
											       out_sect);
					    nextgen = reassign_links(old_out_sect, 
								     out_sect,
								     previous_next,
								     nextgen,
								     &previous_third,
								     thirdgen);
					    previous_third = (lang_input_section_type *)NULL;
					    old_out_sect->section_was_split = true;
					    previous_next = (union lang_statement_union *)NULL;
					    lines = relocs = 0;
					}
					lines += thirdgen->section->lineno_count;
					relocs += thirdgen->section->reloc_count;
					previous_third = thirdgen;
					thirdgen = (lang_input_section_type *)thirdgen->header.next;
				}
			}
			previous_next = nextgen;
			nextgen = nextgen->header.next;
		}

		out_sect = (lang_output_section_statement_type *)
			out_sect->next;
	}

}
